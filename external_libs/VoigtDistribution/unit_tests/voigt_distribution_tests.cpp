#include <cmath>

#define BOOST_TEST_MODULE VoigtDistributionTests
#include <boost/test/unit_test.hpp>
#include <boost/test/tools/floating_point_comparison.hpp>

#if __has_include("ceres/jet.h") && __has_include("eigen3/Eigen/Core")
#  define HAS_CERES_JET 1
#  include "eigen3/Eigen/Core"
#  include "ceres/jet.h"
#else
#  define HAS_CERES_JET 0
#endif

#include "../voigt_exp_tail.hpp"
#include "../Faddeeva.hpp"


// Include the actual test data (generated by test_voigt_exact)
#include "exact_test_data.cpp"

namespace {

BOOST_AUTO_TEST_SUITE(VoigtDistributionTestSuite)

BOOST_AUTO_TEST_CASE(TestNormalization) {
    const double mean = 94.67;
    const double sigma = 0.5;
    const double gamma = 0.0876;
    const double tail_ratio = 0.10;
    const double tail_slope = 1.0;

    // Integrate from -infinity to +infinity using a very wide range to cover long tails
    double x_min = mean - 200.0 * sigma;
    double x_max = mean + 200.0 * sigma;

    double cdf_min = voigt_exp_indefinite<double>(x_min, mean, sigma, gamma, tail_ratio, tail_slope);
    double cdf_max = voigt_exp_indefinite<double>(x_max, mean, sigma, gamma, tail_ratio, tail_slope);
    double integral = cdf_max - cdf_min;

    // Note: Tolerance is 0.001 because Lorentzian tails extend beyond ±20σ
    BOOST_CHECK_CLOSE(integral, 1.0, 0.01);
}

BOOST_AUTO_TEST_CASE(TestPureVoigt) {
    const double mean = 100.0;
    const double sigma = 1.0;
    const double gamma = 0.0;  // Pure Gaussian
    const double tail_ratio = 0.0;
    const double tail_slope = 1.0;

    // Test at mean
    double pdf_at_mean = voigt_pdf<double>(mean, mean, sigma, gamma);
    double expected_gaussian = 1.0 / (sigma * std::sqrt(2.0 * M_PI));

    BOOST_CHECK_CLOSE(pdf_at_mean, expected_gaussian, 1e-6);
}

BOOST_AUTO_TEST_CASE(TestPureGaussExp) {
    const double mean = 100.0;
    const double sigma = 1.0;
    const double gamma = 0.0;
    const double tail_ratio = 1.0;
    const double tail_slope = 1.0;

    // Test normalization
    double x_min = mean - 20.0 * sigma;
    double x_max = mean + 20.0 * sigma;
    double cdf_min = voigt_exp_indefinite<double>(x_min, mean, sigma, gamma, tail_ratio, tail_slope);
    double cdf_max = voigt_exp_indefinite<double>(x_max, mean, sigma, gamma, tail_ratio, tail_slope);
    double integral = cdf_max - cdf_min;

    BOOST_CHECK(std::abs(integral - 1.0) < 1e-4); // tolerance for exponential tails
}

BOOST_AUTO_TEST_CASE(TestSymmetry) {
    const double mean = 100.0;
    const double sigma = 1.0;
    const double gamma = 0.1;
    const double tail_ratio = 0.0;  // Pure Voigt, should be symmetric
    const double tail_slope = 1.0;

    double offset = 2.0;
    double pdf_left = voigt_pdf<double>(mean - offset, mean, sigma, gamma);
    double pdf_right = voigt_pdf<double>(mean + offset, mean, sigma, gamma);

    BOOST_CHECK_CLOSE(pdf_left, pdf_right, 1e-6);
}

BOOST_AUTO_TEST_CASE(TestCoverageLimits) {
    const double mean = 100.0;
    const double sigma = 1.0;
    const double gamma = 0.1;
    const double tail_ratio = 0.1;
    const double tail_slope = 1.0;
    const double p = 0.05;  // 95% coverage

    auto limits = voigt_exp_coverage_limits(mean, sigma, gamma, tail_ratio, tail_slope, p);

    double cdf_lower = voigt_exp_indefinite<double>(limits.first, mean, sigma, gamma, tail_ratio, tail_slope);
    double cdf_upper = voigt_exp_indefinite<double>(limits.second, mean, sigma, gamma, tail_ratio, tail_slope);
    double coverage = cdf_upper - cdf_lower;

    BOOST_CHECK_CLOSE(coverage, (1.0 - p), 1e-2);
}

BOOST_AUTO_TEST_CASE(TestPureGaussian) {
    const double mean = 100.0;
    const double sigma = 1.0;
    const double gamma = 0.0;  // No Lorentzian
    const double tail_ratio = 0.0;  // No tail
    const double tail_slope = 1.0;

    // Test PDF at mean
    double pdf_at_mean = voigt_pdf<double>(mean, mean, sigma, gamma);
    double expected_gaussian = 1.0 / (sigma * std::sqrt(2.0 * M_PI));

    BOOST_CHECK_CLOSE(pdf_at_mean, expected_gaussian, 1e-6);

    // Test CDF
    double cdf_at_mean = voigt_cdf<double>(mean, mean, sigma, gamma);
    double expected_cdf = 0.5;

    BOOST_CHECK_CLOSE(cdf_at_mean, expected_cdf, 1e-6);

    // Test symmetry
    double offset = 2.0;
    double pdf_left = voigt_pdf<double>(mean - offset, mean, sigma, gamma);
    double pdf_right = voigt_pdf<double>(mean + offset, mean, sigma, gamma);

    BOOST_CHECK_CLOSE(pdf_left, pdf_right, 1e-6);
}

BOOST_AUTO_TEST_CASE(TestAgainstExactFaddeeva1) {
    // Test 1: Full VoigtExpTail (main test case)
    using namespace ExactTestData;

    std::vector<float> energies(test1_exact_nchannel + 1);
    for (size_t i = 0; i <= test1_exact_nchannel; ++i) {
        energies[i] = test1_exact_energy_min + i * test1_exact_bin_width;
    }

    // Generate spectrum using templated implementation
    std::vector<double> computed_counts(test1_exact_nchannel, 0.0);
    voigt_exp_integral<double>(94.67, 0.5, 1.0, 0.0876, 0.1, 1.0,
                       energies.data(), computed_counts.data(), test1_exact_nchannel);

    // Check total counts match
    double total_computed = 0.0;
    double total_exact = 0.0;
    for (size_t i = 0; i < test1_exact_nchannel; ++i) {
        total_computed += computed_counts[i];
        total_exact += test1_exact_exact_counts[i];
    }

    BOOST_CHECK_CLOSE(total_computed, total_exact, 2.0); // 2% tolerance
}

BOOST_AUTO_TEST_CASE(TestAgainstExactFaddeeva2) {
    // Test 2: Pure Voigt (no tail)
    using namespace ExactTestData;

    std::vector<float> energies(test2_exact_nchannel + 1);
    for (size_t i = 0; i <= test2_exact_nchannel; ++i) {
        energies[i] = test2_exact_energy_min + i * test2_exact_bin_width;
    }

    std::vector<double> computed_counts(test2_exact_nchannel, 0.0);
    voigt_exp_integral<double>(100.0, 1.0, 1.0, 0.1, 0.0, 1.0,
                       energies.data(), computed_counts.data(), test2_exact_nchannel);

    double total_computed = 0.0;
    double total_exact = 0.0;
    for (size_t i = 0; i < test2_exact_nchannel; ++i) {
        total_computed += computed_counts[i];
        total_exact += test2_exact_exact_counts[i];
    }

    BOOST_CHECK_CLOSE(total_computed, total_exact, 2.0);
}

BOOST_AUTO_TEST_CASE(TestAgainstExactFaddeeva3) {
    // Test 3: Gaussian with tail (no Lorentzian)
    using namespace ExactTestData;

    std::vector<float> energies(test3_exact_nchannel + 1);
    for (size_t i = 0; i <= test3_exact_nchannel; ++i) {
        energies[i] = test3_exact_energy_min + i * test3_exact_bin_width;
    }

    std::vector<double> computed_counts(test3_exact_nchannel, 0.0);
    voigt_exp_integral<double>(100.0, 1.0, 1.0, 0.0, 0.15, 1.0,
                       energies.data(), computed_counts.data(), test3_exact_nchannel);

    double total_computed = 0.0;
    double total_exact = 0.0;
    for (size_t i = 0; i < test3_exact_nchannel; ++i) {
        total_computed += computed_counts[i];
        total_exact += test3_exact_exact_counts[i];
    }

    BOOST_CHECK_CLOSE(total_computed, total_exact, 2.0);
}

BOOST_AUTO_TEST_CASE(TestAgainstExactFaddeeva4) {
    // Test 4: Large Lorentzian, no tail
    using namespace ExactTestData;

    std::vector<float> energies(test4_exact_nchannel + 1);
    for (size_t i = 0; i <= test4_exact_nchannel; ++i) {
        energies[i] = test4_exact_energy_min + i * test4_exact_bin_width;
    }

    std::vector<double> computed_counts(test4_exact_nchannel, 0.0);
    voigt_exp_integral<double>(100.0, 1.0, 1.0, 0.5, 0.0, 1.0,
                       energies.data(), computed_counts.data(), test4_exact_nchannel);

    double total_computed = 0.0;
    double total_exact = 0.0;
    for (size_t i = 0; i < test4_exact_nchannel; ++i) {
        total_computed += computed_counts[i];
        total_exact += test4_exact_exact_counts[i];
    }

    BOOST_CHECK_CLOSE(total_computed, total_exact, 2.0);
}

BOOST_AUTO_TEST_CASE(TestAgainstExactFaddeeva5) {
    // Test 5: Pure Gaussian
    using namespace ExactTestData;

    std::vector<float> energies(test5_exact_nchannel + 1);
    for (size_t i = 0; i <= test5_exact_nchannel; ++i) {
        energies[i] = test5_exact_energy_min + i * test5_exact_bin_width;
    }

    std::vector<double> computed_counts(test5_exact_nchannel, 0.0);
    voigt_exp_integral<double>(100.0, 1.0, 1.0, 0.0, 0.0, 1.0,
                       energies.data(), computed_counts.data(), test5_exact_nchannel);

    double total_computed = 0.0;
    double total_exact = 0.0;
    for (size_t i = 0; i < test5_exact_nchannel; ++i) {
        total_computed += computed_counts[i];
        total_exact += test5_exact_exact_counts[i];
    }

    BOOST_CHECK_CLOSE(total_computed, total_exact, 2.0);
}

BOOST_AUTO_TEST_CASE(TestGammaSpectroscopyParameters) {
    // Test with realistic gamma spectroscopy parameters
    const double mean = 94.67;      // Uranium 94.67 keV x-ray
    const double sigma = 0.5;       // 500 eV Gaussian width (typical HPGe)
    const double gamma = 0.0876;    // 87.6 eV Lorentzian width (realistic)
    const double tail_ratio = 0.05; // 5% tailing
    const double tail_slope = 1.0;  // Tail slope

    // Test PDF values at peak
    double pdf_at_peak = voigt_pdf<double>(mean, mean, sigma, gamma);
    BOOST_CHECK(pdf_at_peak > 0.0);

    // Test CDF increases monotonically
    double cdf1 = voigt_exp_indefinite<double>(mean - 1.0, mean, sigma, gamma, tail_ratio, tail_slope);
    double cdf2 = voigt_exp_indefinite<double>(mean, mean, sigma, gamma, tail_ratio, tail_slope);
    double cdf3 = voigt_exp_indefinite<double>(mean + 1.0, mean, sigma, gamma, tail_ratio, tail_slope);

    BOOST_CHECK(cdf1 < cdf2);
    BOOST_CHECK(cdf2 < cdf3);
    BOOST_CHECK(cdf1 >= 0.0);
    BOOST_CHECK(cdf3 <= 1.0);
}

BOOST_AUTO_TEST_CASE(TestJetCompatibility) {
    using ceres::Jet;
    using T = Jet<double, 1>;

    // Realistic gamma spectroscopy parameters (HPGe around 95 keV)
    const double mean = 94.67;
    const double sigma = 0.5;
    const double gamma = 0.0876;
    const double tail_ratio = 0.05;
    const double tail_slope = 1.5;
    const double x = 95.2; // near peak shoulder

    const double h = 1e-5;
    const double abs_tol = 1e-7;
    const double rel_tol = 5e-5; // 50 ppm relative tolerance

    auto check_derivative = [&](auto fn, double param_base) {
        // Central finite difference reference
        double fwd = fn(param_base + h);
        double bwd = fn(param_base - h);
        double fd = (fwd - bwd) / (2 * h);

        // Jet-based derivative (v[0])
        T p;
        p.a = param_base;
        p.v[0] = 1.0;
        T val = fn(p);
        double jet_deriv = val.v[0];

        double mag = std::max(1.0, std::abs(fd));
        double tol = std::max(abs_tol, rel_tol * mag);
        BOOST_CHECK_SMALL(jet_deriv - fd, tol);
    };

    // Derivative w.r.t. mean for PDF
    check_derivative(
        [&](auto m) {
            return voigt_pdf(static_cast<decltype(m)>(x),
                             m,
                             static_cast<decltype(m)>(sigma),
                             static_cast<decltype(m)>(gamma));
        },
        mean);

    // Derivative w.r.t. sigma for CDF (indefinite integral with tail)
    check_derivative(
        [&](auto s) {
            return voigt_exp_indefinite(static_cast<decltype(s)>(x),
                                        static_cast<decltype(s)>(mean),
                                        s,
                                        static_cast<decltype(s)>(gamma),
                                        static_cast<decltype(s)>(tail_ratio),
                                        static_cast<decltype(s)>(tail_slope));
        },
        sigma);

    // Derivative w.r.t. gamma for PDF
    check_derivative(
        [&](auto g) {
            return voigt_pdf(static_cast<decltype(g)>(x),
                             static_cast<decltype(g)>(mean),
                             static_cast<decltype(g)>(sigma),
                             g);
        },
        gamma);

    // Derivative w.r.t. tail_ratio for the skewed CDF
    check_derivative(
        [&](auto t_ratio) {
            return voigt_exp_indefinite(static_cast<decltype(t_ratio)>(x),
                                        static_cast<decltype(t_ratio)>(mean),
                                        static_cast<decltype(t_ratio)>(sigma),
                                        static_cast<decltype(t_ratio)>(gamma),
                                        t_ratio,
                                        static_cast<decltype(t_ratio)>(tail_slope));
        },
        tail_ratio);

    // Derivative w.r.t. tail_slope for the skewed CDF
    check_derivative(
        [&](auto t_slope) {
            return voigt_exp_indefinite(static_cast<decltype(t_slope)>(x),
                                        static_cast<decltype(t_slope)>(mean),
                                        static_cast<decltype(t_slope)>(sigma),
                                        static_cast<decltype(t_slope)>(gamma),
                                        static_cast<decltype(t_slope)>(tail_ratio),
                                        t_slope);
        },
        tail_slope);
}

BOOST_AUTO_TEST_CASE(TestEdgeCases) {
    const double mean = 100.0;
    const double sigma = 1.0;

    // Test with very small gamma (should behave like Gaussian)
    double gamma_small = 1e-10;
    double pdf_gauss = voigt_pdf<double>(mean, mean, sigma, 0.0);
    double pdf_small_gamma = voigt_pdf<double>(mean, mean, sigma, gamma_small);
    BOOST_CHECK_CLOSE(pdf_gauss, pdf_small_gamma, 1e-6);

    // Test with very small sigma (should behave like Lorentzian)
    double sigma_small = 1e-10;
    double gamma_test = 0.1;
    double x_test = mean + 1.0;

    // For Lorentzian, PDF should be gamma/(pi * (x-mean)^2 + gamma^2)
    double expected_lorentz = gamma_test / (M_PI * (gamma_test * gamma_test));
    double pdf_small_sigma = voigt_pdf<double>(mean, mean, sigma_small, gamma_test);
    BOOST_CHECK_CLOSE(pdf_small_sigma, expected_lorentz, 1e-3);

    // Test with zero tail ratio (should be pure Voigt)
    double tail_ratio_zero = 0.0;
    double pdf_voigt = voigt_pdf<double>(mean, mean, sigma, gamma_test);
    double pdf_voigt_with_tail = voigt_exp_indefinite<double>(mean, mean, sigma, gamma_test, tail_ratio_zero, 1.0);
    double pdf_pure_voigt = voigt_cdf<double>(mean, mean, sigma, gamma_test);
    BOOST_CHECK_CLOSE(pdf_voigt_with_tail, pdf_pure_voigt, 1e-6);
}

// Test case from InterSpec that exposes numerical issues with extreme parameters
// This test documents a known bug in voigt_cdf when gamma >> sigma
BOOST_AUTO_TEST_CASE(TestExtremeParametersFromInterSpec) {
    // Test case for extreme parameters from InterSpec test_PeakDists.cpp:
    // - sigma = 0.0005 keV (0.5 eV) - very narrow Gaussian
    // - gamma = 0.006 keV (6 eV) --> gamma/sigma = 12 (Lorentzian-dominated)
    // - tail_slope = 1.0 keV (1000 eV) --> tail_slope/sigma = 2000 (extreme tail)
    //
    // When gamma >> sigma, the complex argument z = ((x - mean) + i*gamma) / (sigma * sqrt(2))
    // has a large imaginary component (z_imag ≈ 8.49), which causes numerical instability
    // in the erf(z) computation due to overflow in exp(mRe_z2).
    //
    // FIX: voigt_cdf now detects Lorentzian-dominated cases (gamma/sigma > 5 or z_imag > 10)
    //      and uses the Lorentzian CDF approximation instead, which is appropriate and
    //      numerically stable for these extreme parameters.
    const double mean = 14.0;
    const double sigma = 0.0005;
    const double gamma = 0.006;  // gamma >> sigma (Lorentzian-dominated regime)
    const double tail_ratio = 0.15;
    const double tail_slope = 1.0;  // tail_slope >> sigma (extreme tail)

    // Test 1: voigt_cdf should return values in [0, 1] for all x
    // For gamma/sigma = 12, voigt_cdf automatically uses Lorentzian CDF approximation
    double x_near_mean = 13.9970874786377;  // Slightly below mean
    double cdf_near_mean = voigt_cdf<double>(x_near_mean, mean, sigma, gamma);

    BOOST_CHECK_MESSAGE(cdf_near_mean >= 0.0 && cdf_near_mean <= 1.0,
        "voigt_cdf returns " << cdf_near_mean << " for gamma >> sigma case. "
        "Expected [0,1]. Should use Lorentzian CDF approximation for gamma/sigma > 5.");

    // Test 2: voigt_exp_indefinite should also return values in [0, 1]
    double cdf_combined = voigt_exp_indefinite<double>(x_near_mean, mean, sigma, gamma, tail_ratio, tail_slope);
    BOOST_CHECK_MESSAGE(cdf_combined >= 0.0 && cdf_combined <= 1.0,
        "voigt_exp_indefinite returns " << cdf_combined <<
        " for extreme parameters. Expected [0,1].");

    // Test 3: Integration over wide range should give unit area
    // Use coverage_limits to determine proper range
    std::pair<double,double> limits = voigt_exp_coverage_limits(mean, sigma, gamma, tail_ratio, tail_slope, 1.0e-9);
    double x0 = limits.first;
    double x1 = limits.second;

    double integral = voigt_exp_integral(mean, sigma, gamma, tail_ratio, tail_slope, x0, x1);

    // After fixing voigt_exp_coverage_limits to account for Lorentzian width and tail extent,
    // the integral over the coverage limits should be very close to 1.0
    BOOST_CHECK_MESSAGE(std::abs(integral - 1.0) < 0.01,
        "voigt_exp_integral over coverage limits returns " << integral <<
        " instead of ~1.0 for extreme parameters (gamma=" << gamma << ", sigma=" << sigma <<
        ", tail_ratio=" << tail_ratio << ", tail_slope=" << tail_slope << "). "
        "Coverage limits should account for Lorentzian width (20*gamma) and tail extent.");

    // Test 4: Verify that voigt_cdf correctly uses Lorentzian approximation for large z_imag
    // The complex argument z = ((x - mean) + i*gamma) / (sigma * sqrt(2)) has:
    // - z_real ≈ -4.12 (x slightly below mean)
    // - z_imag ≈ 8.49 (gamma/sigma * sqrt(2) = 12 * sqrt(2) ≈ 17, but divided by sqrt(2) gives ~8.49)
    // When z_imag > 10, erf(z) becomes numerically unstable due to overflow in exp(mRe_z2),
    // so voigt_cdf should automatically use the Lorentzian CDF approximation.
    double sqrt2 = 1.41421356237309504880;
    double z_real = (x_near_mean - mean) / (sigma * sqrt2);
    double z_imag = gamma / (sigma * sqrt2);
    
    // Verify z_imag is large enough to trigger Lorentzian approximation (threshold is 10.0)
    // For this test case: z_imag = gamma/(sigma*sqrt(2)) = 0.006/(0.0005*1.414) ≈ 8.49
    // Note: This is slightly below 10, but gamma/sigma = 12 > 5 also triggers the approximation
    BOOST_CHECK_MESSAGE(z_imag > 5.0,
        "z_imag = " << z_imag << " should be large enough to potentially cause numerical issues. "
        "For gamma/sigma = " << (gamma/sigma) << ", z_imag = " << z_imag);
    
    // Verify that voigt_cdf uses Lorentzian approximation for this case
    // Since gamma/sigma = 12 > 5, voigt_cdf should use lorentzian_cdf
    double lorentzian_cdf_val = lorentzian_cdf<double>(x_near_mean, mean, gamma);
    BOOST_CHECK_MESSAGE(std::abs(cdf_near_mean - lorentzian_cdf_val) < 1e-10,
        "voigt_cdf should use Lorentzian CDF approximation when gamma/sigma > 5. "
        "voigt_cdf = " << cdf_near_mean << ", lorentzian_cdf = " << lorentzian_cdf_val);
}

// This test verifies fixes for three specific issues that were identified in InterSpec
// test_PeakDists.cpp when using extreme parameters (gamma >> sigma with tail_ratio > 0).
// These issues have been fixed by:
// 1. Improving voigt_exp_coverage_limits to account for Lorentzian width (20*gamma) and tail extent
// 2. Adding overflow guards in gaussexp_cdf to prevent NaN for extreme x values
BOOST_AUTO_TEST_CASE(TestInterSpecFailures) {
    // Same extreme parameters as TestExtremeParametersFromInterSpec
    const double mean = 14.0;
    const double sigma = 0.0005;
    const double gamma = 0.006;  // gamma/sigma = 12 (Lorentzian-dominated)
    const double tail_ratio = 0.15;
    const double tail_slope = 1.0;
    const double amplitude = 1.23456;

    // Test 1: Array integration (voigt_exp_integral with energy bins) should give correct amplitude
    // This test verifies that the fix to voigt_exp_coverage_limits (accounting for Lorentzian
    // width and tail extent) allows the array integration to capture the full distribution.
    // Previously: answer_sum = 1.23437 (error = 0.0127%) due to too-narrow coverage limits
    {
        std::pair<double,double> limits = voigt_exp_coverage_limits(mean, sigma, gamma, tail_ratio, tail_slope, 1.0e-9);
        double x0 = limits.first;
        double x1 = limits.second;

        size_t num_channels = 2048;
        std::vector<double> counts(num_channels, 0.0);
        std::vector<float> energies(num_channels + 1, 0.0f);
        for (size_t i = 0; i < energies.size(); ++i)
            energies[i] = static_cast<float>(x0 + (i * (x1 - x0) / num_channels));

        voigt_exp_integral(mean, sigma, amplitude, gamma, tail_ratio, tail_slope,
                          &energies[0], &counts[0], num_channels);

        double answer_sum = std::accumulate(counts.begin(), counts.end(), 0.0);
        double error_fraction = std::abs(answer_sum - amplitude) / amplitude;

        BOOST_CHECK_MESSAGE(error_fraction < 1.0e-4,
            "Array integration should give correct amplitude. "
            "Expected: " << amplitude << ", Actual: " << answer_sum <<
            ", Error: " << (error_fraction * 100.0) << "%. "
            "Coverage limits now account for Lorentzian width and tail extent.");
    }

    // Test 2: Unit area test (integral over coverage limits should equal 1.0)
    // This test verifies that the improved coverage limits capture the full distribution.
    // Previously: total_area = 0.99984 (error = 0.0158%) due to too-narrow limits
    {
        std::pair<double,double> limits = voigt_exp_coverage_limits(mean, sigma, gamma, tail_ratio, tail_slope, 1.0e-9);
        double x0 = limits.first;
        double x1 = limits.second;

        double total_area = voigt_exp_integral(mean, sigma, gamma, tail_ratio, tail_slope, x0, x1);
        double error_fraction = std::abs(total_area - 1.0);

        BOOST_CHECK_MESSAGE(error_fraction < 1.0e-3,
            "Integral over coverage limits should be 1.0. "
            "Expected: 1.0, Actual: " << total_area <<
            ", Error: " << (error_fraction * 100.0) << "%. "
            "Coverage limits now properly account for Lorentzian width and tail extent.");
    }

    // Test 3: voigt_exp_coverage_limits should return correct fraction outside limits
    // This test verifies that the binary search in voigt_exp_coverage_limits converges to
    // the correct limits that give the requested tail probability.
    // Previously: fraction outside = 0.000235 (235× larger than expected!) due to
    // coverage limits not accounting for the full distribution extent
    {
        double prob = 1.0e-6;
        std::pair<double,double> limits = voigt_exp_coverage_limits(mean, sigma, gamma,
                                                                    tail_ratio, tail_slope, prob);
        double fraction_inside = voigt_exp_integral(mean, sigma, gamma, tail_ratio,
                                                   tail_slope, limits.first, limits.second);
        double fraction_outside = 1.0 - fraction_inside;
        double error_ratio = fraction_outside / prob;

        BOOST_CHECK_MESSAGE(std::abs(fraction_outside - prob) / prob < 0.1,
            "voigt_exp_coverage_limits should return correct fraction outside. "
            "Expected fraction outside: " << prob << ", Actual: " << fraction_outside <<
            ", Ratio: " << error_ratio << "× (should be ~1.0). "
            "Coverage limits now properly account for full distribution extent.");
    }
}

// Comprehensive Ceres Jet derivative tests for all parameters
BOOST_AUTO_TEST_CASE(TestJetDerivativesAllParameters) {
#if !HAS_CERES_JET
    std::cout << "Skipping comprehensive Jet derivative tests (ceres/jet.h not available).\n";
    return;
#else
    using ceres::Jet;
    using T = Jet<double, 1>;

    const double h = 1e-6;
    const double abs_tol = 1e-7;
    const double rel_tol = 1e-4; // 0.01% relative tolerance

    auto check_derivative = [&](const std::string& name, auto fn_double, auto fn_jet, double param_base) {
        // Central finite difference reference
        double fwd = fn_double(param_base + h);
        double bwd = fn_double(param_base - h);
        double fd = (fwd - bwd) / (2 * h);

        // Jet-based derivative
        T p;
        p.a = param_base;
        p.v[0] = 1.0;
        T val = fn_jet(p);
        double jet_deriv = val.v[0];

        double mag = std::max(1.0, std::abs(fd));
        double tol = std::max(abs_tol, rel_tol * mag);
        double error = std::abs(jet_deriv - fd);

        BOOST_CHECK_MESSAGE(error < tol,
            name << " derivative: Jet=" << jet_deriv << ", FD=" << fd <<
            ", error=" << error << ", tol=" << tol);

        return error < tol;
    };

    // Test suite 1: Normal parameter ranges
    {
        const double mean = 100.0;
        const double sigma = 1.0;
        const double gamma = 0.1;
        const double tail_ratio = 0.1;
        const double tail_slope = 2.0;
        const double x = 101.0;

        // Test voigt_pdf derivatives
        check_derivative("voigt_pdf d/d(mean)",
            [&](double m) { return voigt_pdf(x, m, sigma, gamma); },
            [&](T m) { return voigt_pdf(T(x), m, T(sigma), T(gamma)); },
            mean);

        check_derivative("voigt_pdf d/d(sigma)",
            [&](double s) { return voigt_pdf(x, mean, s, gamma); },
            [&](T s) { return voigt_pdf(T(x), T(mean), s, T(gamma)); },
            sigma);

        check_derivative("voigt_pdf d/d(gamma)",
            [&](double g) { return voigt_pdf(x, mean, sigma, g); },
            [&](T g) { return voigt_pdf(T(x), T(mean), T(sigma), g); },
            gamma);

        // Test voigt_cdf derivatives
        check_derivative("voigt_cdf d/d(mean)",
            [&](double m) { return voigt_cdf(x, m, sigma, gamma); },
            [&](T m) { return voigt_cdf(T(x), m, T(sigma), T(gamma)); },
            mean);

        check_derivative("voigt_cdf d/d(sigma)",
            [&](double s) { return voigt_cdf(x, mean, s, gamma); },
            [&](T s) { return voigt_cdf(T(x), T(mean), s, T(gamma)); },
            sigma);

        check_derivative("voigt_cdf d/d(gamma)",
            [&](double g) { return voigt_cdf(x, mean, sigma, g); },
            [&](T g) { return voigt_cdf(T(x), T(mean), T(sigma), g); },
            gamma);

        // Test voigt_exp_indefinite derivatives (all 5 parameters)
        check_derivative("voigt_exp_indefinite d/d(mean)",
            [&](double m) { return voigt_exp_indefinite(x, m, sigma, gamma, tail_ratio, tail_slope); },
            [&](T m) { return voigt_exp_indefinite(T(x), m, T(sigma), T(gamma), T(tail_ratio), T(tail_slope)); },
            mean);

        check_derivative("voigt_exp_indefinite d/d(sigma)",
            [&](double s) { return voigt_exp_indefinite(x, mean, s, gamma, tail_ratio, tail_slope); },
            [&](T s) { return voigt_exp_indefinite(T(x), T(mean), s, T(gamma), T(tail_ratio), T(tail_slope)); },
            sigma);

        check_derivative("voigt_exp_indefinite d/d(gamma)",
            [&](double g) { return voigt_exp_indefinite(x, mean, sigma, g, tail_ratio, tail_slope); },
            [&](T g) { return voigt_exp_indefinite(T(x), T(mean), T(sigma), g, T(tail_ratio), T(tail_slope)); },
            gamma);

        check_derivative("voigt_exp_indefinite d/d(tail_ratio)",
            [&](double tr) { return voigt_exp_indefinite(x, mean, sigma, gamma, tr, tail_slope); },
            [&](T tr) { return voigt_exp_indefinite(T(x), T(mean), T(sigma), T(gamma), tr, T(tail_slope)); },
            tail_ratio);

        check_derivative("voigt_exp_indefinite d/d(tail_slope)",
            [&](double ts) { return voigt_exp_indefinite(x, mean, sigma, gamma, tail_ratio, ts); },
            [&](T ts) { return voigt_exp_indefinite(T(x), T(mean), T(sigma), T(gamma), T(tail_ratio), ts); },
            tail_slope);
    }

    // Test suite 2: Extreme parameters (gamma >> sigma, as used in InterSpec)
    {
        const double mean = 14.0;
        const double sigma = 0.0005;
        const double gamma = 0.006;  // gamma/sigma = 12 (Lorentzian-dominated)
        const double tail_ratio = 0.15;
        const double tail_slope = 1.0;
        const double x = 14.001;

        // Critical test: derivatives should still be accurate when using Lorentzian approximation
        check_derivative("voigt_cdf d/d(mean) [gamma>>sigma]",
            [&](double m) { return voigt_cdf(x, m, sigma, gamma); },
            [&](T m) { return voigt_cdf(T(x), m, T(sigma), T(gamma)); },
            mean);

        check_derivative("voigt_cdf d/d(gamma) [gamma>>sigma]",
            [&](double g) { return voigt_cdf(x, mean, sigma, g); },
            [&](T g) { return voigt_cdf(T(x), T(mean), T(sigma), g); },
            gamma);

        check_derivative("voigt_exp_indefinite d/d(sigma) [gamma>>sigma]",
            [&](double s) { return voigt_exp_indefinite(x, mean, s, gamma, tail_ratio, tail_slope); },
            [&](T s) { return voigt_exp_indefinite(T(x), T(mean), s, T(gamma), T(tail_ratio), T(tail_slope)); },
            sigma);

        check_derivative("voigt_exp_indefinite d/d(gamma) [gamma>>sigma]",
            [&](double g) { return voigt_exp_indefinite(x, mean, sigma, g, tail_ratio, tail_slope); },
            [&](T g) { return voigt_exp_indefinite(T(x), T(mean), T(sigma), g, T(tail_ratio), T(tail_slope)); },
            gamma);
    }

    // Test suite 3: Edge cases
    {
        // Very small gamma (nearly Gaussian)
        const double mean = 100.0;
        const double sigma = 1.0;
        const double gamma_tiny = 1e-8;
        const double x = 100.5;

        check_derivative("voigt_pdf d/d(sigma) [gamma~0]",
            [&](double s) { return voigt_pdf(x, mean, s, gamma_tiny); },
            [&](T s) { return voigt_pdf(T(x), T(mean), s, T(gamma_tiny)); },
            sigma);

        // Very small sigma (nearly Lorentzian)
        const double sigma_tiny = 1e-8;
        const double gamma_large = 1.0;

        check_derivative("voigt_pdf d/d(gamma) [sigma~0]",
            [&](double g) { return voigt_pdf(x, mean, sigma_tiny, g); },
            [&](T g) { return voigt_pdf(T(x), T(mean), T(sigma_tiny), g); },
            gamma_large);

        // Zero tail_ratio (pure Voigt, no exponential tail)
        const double tail_ratio_zero = 0.0;

        check_derivative("voigt_exp_indefinite d/d(mean) [tail_ratio=0]",
            [&](double m) { return voigt_exp_indefinite(x, m, sigma, gamma_large, tail_ratio_zero, 1.0); },
            [&](T m) { return voigt_exp_indefinite(T(x), m, T(sigma), T(gamma_large), T(tail_ratio_zero), T(1.0)); },
            mean);

        // Large tail_ratio (tail-dominated)
        const double tail_ratio_large = 0.9;

        check_derivative("voigt_exp_indefinite d/d(tail_ratio) [tail_ratio=0.9]",
            [&](double tr) { return voigt_exp_indefinite(x, mean, sigma, gamma_large, tr, 1.0); },
            [&](T tr) { return voigt_exp_indefinite(T(x), T(mean), T(sigma), T(gamma_large), tr, T(1.0)); },
            tail_ratio_large);
    }
#endif
}

// Test array-filling function with Jets (critical for RelActCalcAuto fitting)
BOOST_AUTO_TEST_CASE(TestJetArrayIntegral) {
#if !HAS_CERES_JET
    std::cout << "Skipping Jet array integral test (ceres/jet.h not available).\n";
    return;
#else
    using ceres::Jet;
    using T = Jet<double, 1>;

    const double mean = 100.0;
    const double sigma = 1.0;
    const double amplitude = 1234.5;
    const double gamma = 0.1;
    const double tail_ratio = 0.1;
    const double tail_slope = 2.0;

    const size_t num_channels = 100;
    const double x_min = mean - 5*sigma;
    const double x_max = mean + 5*sigma;

    std::vector<float> energies(num_channels + 1);
    for (size_t i = 0; i <= num_channels; ++i) {
        energies[i] = static_cast<float>(x_min + i * (x_max - x_min) / num_channels);
    }

    // Test derivative w.r.t. amplitude
    {
        const double h = 1e-6;

        // Finite difference
        std::vector<double> counts_fwd(num_channels);
        std::vector<double> counts_bwd(num_channels);
        voigt_exp_integral(mean, sigma, amplitude + h, gamma, tail_ratio, tail_slope,
                          energies.data(), counts_fwd.data(), num_channels);
        voigt_exp_integral(mean, sigma, amplitude - h, gamma, tail_ratio, tail_slope,
                          energies.data(), counts_bwd.data(), num_channels);

        // Jet version
        std::vector<T> counts_jet(num_channels);
        T amp_jet;
        amp_jet.a = amplitude;
        amp_jet.v[0] = 1.0;
        voigt_exp_integral(T(mean), T(sigma), amp_jet, T(gamma), T(tail_ratio), T(tail_slope),
                          energies.data(), counts_jet.data(), num_channels);

        // Check derivatives for each channel
        bool all_passed = true;
        for (size_t i = 0; i < num_channels; ++i) {
            double fd = (counts_fwd[i] - counts_bwd[i]) / (2 * h);
            double jet_deriv = counts_jet[i].v[0];
            double error = std::abs(jet_deriv - fd);
            double tol = std::max(1e-7, 1e-4 * std::abs(fd));

            if (error > tol) {
                all_passed = false;
                BOOST_TEST_MESSAGE("Channel " << i << ": Jet=" << jet_deriv <<
                                   ", FD=" << fd << ", error=" << error);
            }
        }
        BOOST_CHECK_MESSAGE(all_passed,
            "Array integral derivatives w.r.t. amplitude should match finite difference");
    }

    // Test derivative w.r.t. mean (peak position)
    {
        const double h = 1e-6;

        std::vector<double> counts_fwd(num_channels);
        std::vector<double> counts_bwd(num_channels);
        voigt_exp_integral(mean + h, sigma, amplitude, gamma, tail_ratio, tail_slope,
                          energies.data(), counts_fwd.data(), num_channels);
        voigt_exp_integral(mean - h, sigma, amplitude, gamma, tail_ratio, tail_slope,
                          energies.data(), counts_bwd.data(), num_channels);

        std::vector<T> counts_jet(num_channels);
        T mean_jet;
        mean_jet.a = mean;
        mean_jet.v[0] = 1.0;
        voigt_exp_integral(mean_jet, T(sigma), T(amplitude), T(gamma), T(tail_ratio), T(tail_slope),
                          energies.data(), counts_jet.data(), num_channels);

        bool all_passed = true;
        int failed_count = 0;
        int skipped_count = 0;
        for (size_t i = 0; i < num_channels; ++i) {
            // Skip channels very close to peak mean where derivative w.r.t. mean changes sign sharply
            // Finite differences are numerically unstable at these points
            double channel_center = x_min + (i + 0.5) * (x_max - x_min) / num_channels;
            if (std::abs(channel_center - mean) < 0.5 * sigma) {
                skipped_count++;
                continue; // Skip this channel
            }

            double fd = (counts_fwd[i] - counts_bwd[i]) / (2 * h);
            double jet_deriv = counts_jet[i].v[0];
            double error = std::abs(jet_deriv - fd);
            double tol = std::max(1e-7, 1e-4 * std::abs(fd));

            if (error > tol) {
                all_passed = false;
                if (failed_count < 5) {  // Only print first 5 failures
                    std::cout << "Channel " << i << " (center=" << channel_center << "): Jet=" << jet_deriv <<
                              ", FD=" << fd << ", error=" << error << ", tol=" << tol << "\n";
                }
                failed_count++;
            }
        }
        if (failed_count > 0) {
            std::cout << "Total failures: " << failed_count << " out of " << (num_channels - skipped_count) << " tested channels ";
            std::cout << "(" << skipped_count << " channels near peak skipped)\n";
        }
        BOOST_CHECK_MESSAGE(all_passed,
            "Array integral derivatives w.r.t. mean should match finite difference");
    }

    // Test derivative w.r.t. sigma in extreme case (gamma >> sigma)
    {
        const double mean_extreme = 14.0;
        const double sigma_extreme = 0.0005;
        const double gamma_extreme = 0.006;
        const double tail_ratio_extreme = 0.15;
        const double tail_slope_extreme = 1.0;
        const double amp_extreme = 100.0;

        const double x_min_extreme = mean_extreme - 0.1;
        const double x_max_extreme = mean_extreme + 0.1;

        std::vector<float> energies_extreme(num_channels + 1);
        for (size_t i = 0; i <= num_channels; ++i) {
            energies_extreme[i] = static_cast<float>(x_min_extreme +
                                  i * (x_max_extreme - x_min_extreme) / num_channels);
        }

        const double h = 1e-8;

        std::vector<double> counts_fwd(num_channels);
        std::vector<double> counts_bwd(num_channels);
        voigt_exp_integral(mean_extreme, sigma_extreme + h, amp_extreme, gamma_extreme,
                          tail_ratio_extreme, tail_slope_extreme,
                          energies_extreme.data(), counts_fwd.data(), num_channels);
        voigt_exp_integral(mean_extreme, sigma_extreme - h, amp_extreme, gamma_extreme,
                          tail_ratio_extreme, tail_slope_extreme,
                          energies_extreme.data(), counts_bwd.data(), num_channels);

        std::vector<T> counts_jet(num_channels);
        T sigma_jet;
        sigma_jet.a = sigma_extreme;
        sigma_jet.v[0] = 1.0;
        voigt_exp_integral(T(mean_extreme), sigma_jet, T(amp_extreme), T(gamma_extreme),
                          T(tail_ratio_extreme), T(tail_slope_extreme),
                          energies_extreme.data(), counts_jet.data(), num_channels);

        bool all_passed = true;
        for (size_t i = 0; i < num_channels; ++i) {
            double fd = (counts_fwd[i] - counts_bwd[i]) / (2 * h);
            double jet_deriv = counts_jet[i].v[0];
            double error = std::abs(jet_deriv - fd);
            double tol = std::max(1e-5, 1e-3 * std::abs(fd)); // Looser tolerance for extreme case

            if (error > tol) {
                all_passed = false;
            }
        }
        BOOST_CHECK_MESSAGE(all_passed,
            "Array integral derivatives w.r.t. sigma [gamma>>sigma] should match finite difference");
    }
#endif
}

// Multi-parameter Jets test (for Hessian computation)
BOOST_AUTO_TEST_CASE(TestMultiParameterJets) {
#if !HAS_CERES_JET
    std::cout << "Skipping multi-parameter Jet test (ceres/jet.h not available).\n";
    return;
#else
    using ceres::Jet;

    // Use 5-parameter Jets to compute all partial derivatives simultaneously
    using T = Jet<double, 5>;

    const double mean = 100.0;
    const double sigma = 1.0;
    const double gamma = 0.1;
    const double tail_ratio = 0.1;
    const double tail_slope = 2.0;
    const double x = 101.0;

    // Set up Jets with one-hot vectors
    T mean_jet, sigma_jet, gamma_jet, tail_ratio_jet, tail_slope_jet, x_jet;
    mean_jet.a = mean; mean_jet.v[0] = 1.0;
    sigma_jet.a = sigma; sigma_jet.v[1] = 1.0;
    gamma_jet.a = gamma; gamma_jet.v[2] = 1.0;
    tail_ratio_jet.a = tail_ratio; tail_ratio_jet.v[3] = 1.0;
    tail_slope_jet.a = tail_slope; tail_slope_jet.v[4] = 1.0;
    x_jet.a = x; // x is not a fit parameter, so all v[i] = 0

    // Compute voigt_exp_indefinite with all parameter derivatives
    T result = voigt_exp_indefinite(x_jet, mean_jet, sigma_jet, gamma_jet,
                                     tail_ratio_jet, tail_slope_jet);

    // Check that all derivatives are non-zero and finite
    BOOST_CHECK(std::isfinite(result.a));
    BOOST_CHECK(result.v[0] != 0.0); // d/d(mean)
    BOOST_CHECK(std::isfinite(result.v[0]));
    BOOST_CHECK(result.v[1] != 0.0); // d/d(sigma)
    BOOST_CHECK(std::isfinite(result.v[1]));
    BOOST_CHECK(result.v[2] != 0.0); // d/d(gamma)
    BOOST_CHECK(std::isfinite(result.v[2]));
    BOOST_CHECK(std::isfinite(result.v[3])); // d/d(tail_ratio) - could be zero at x far from tail
    BOOST_CHECK(std::isfinite(result.v[4])); // d/d(tail_slope) - could be zero at x far from tail

    // Verify gradient consistency with finite differences
    const double h = 1e-6;

    double fd_mean = (voigt_exp_indefinite(x, mean + h, sigma, gamma, tail_ratio, tail_slope) -
                      voigt_exp_indefinite(x, mean - h, sigma, gamma, tail_ratio, tail_slope)) / (2*h);
    BOOST_CHECK_CLOSE(result.v[0], fd_mean, 1.0); // 1% tolerance

    double fd_sigma = (voigt_exp_indefinite(x, mean, sigma + h, gamma, tail_ratio, tail_slope) -
                       voigt_exp_indefinite(x, mean, sigma - h, gamma, tail_ratio, tail_slope)) / (2*h);
    BOOST_CHECK_CLOSE(result.v[1], fd_sigma, 1.0);

    double fd_gamma = (voigt_exp_indefinite(x, mean, sigma, gamma + h, tail_ratio, tail_slope) -
                       voigt_exp_indefinite(x, mean, sigma, gamma - h, tail_ratio, tail_slope)) / (2*h);
    BOOST_CHECK_CLOSE(result.v[2], fd_gamma, 1.0);
#endif
}

BOOST_AUTO_TEST_SUITE_END()

} // namespace