#!/usr/bin/env python3
"""
Generate high-accuracy reference Voigt CDF values using scipy for comparison.
Since scipy doesn't have a direct Voigt CDF, we integrate the Voigt PDF.

This script is intended to be run from the unit_tests/scripts directory and
will write voigt_cdf_reference.hpp/cpp into the parent unit_tests directory.
"""

import numpy as np
from scipy.special import voigt_profile
from scipy.integrate import quad
import json
from pathlib import Path


def voigt_pdf_scipy(x, mean, sigma, gamma):
    """Voigt PDF using scipy."""
    return voigt_profile(x - mean, sigma, gamma)


def voigt_cdf_scipy(x, mean, sigma, gamma):
    """
    Compute Voigt CDF by integrating the PDF from -infinity to x.

    We use a wide lower bound and tight tolerances to get high-accuracy
    reference values suitable for testing.
    """
    width = max(sigma, gamma)
    lower_bound = mean - 80.0 * width

    result, _ = quad(
        voigt_pdf_scipy,
        lower_bound,
        x,
        args=(mean, sigma, gamma),
        epsabs=1e-14,
        epsrel=1e-13,
        limit=2000,
    )
    return result


def generate_cdf_data(mean, sigma, gamma, x_values):
    """Generate CDF values for a list of x values."""
    return [voigt_cdf_scipy(x, mean, sigma, gamma) for x in x_values]


if __name__ == "__main__":
    # Resolve output directory as parent of this script: unit_tests/
    script_dir = Path(__file__).resolve().parent
    out_dir = script_dir.parent

    # Define several test cases for different regimes
    test_cases = [
        {
            "name": "UraniumXray",
            "mean": 94.67,
            "sigma": 0.5,
            "gamma": 0.0876,
            "x_range": (-5.0, 5.0),  # ±5 sigma
            "npoints": 201,
        },
        {
            "name": "GaussianDominatedCDF",
            "mean": 100.0,
            "sigma": 1.0,
            "gamma": 0.01,
            "x_range": (-5.0, 5.0),  # ±5 sigma
            "npoints": 201,
        },
        {
            "name": "LorentzianDominatedCDF",
            "mean": 100.0,
            "sigma": 0.01,
            "gamma": 1.0,
            "x_range": (-10.0, 10.0),  # wider for heavy tails
            "npoints": 401,
        },
        {
            "name": "BalancedCDF",
            "mean": 100.0,
            "sigma": 1.0,
            "gamma": 1.0,
            "x_range": (-8.0, 8.0),
            "npoints": 321,
        },
    ]

    all_data = {}

    for case in test_cases:
        name = case["name"]
        mean = case["mean"]
        sigma = case["sigma"]
        gamma = case["gamma"]
        x_min, x_max = case["x_range"]
        npoints = case["npoints"]

        x_values = np.linspace(mean + x_min, mean + x_max, npoints)

        print(f"\nGenerating CDF reference for {name}:")
        print(f"  mean={mean}, sigma={sigma}, gamma={gamma}")
        print(f"  range=[{mean + x_min}, {mean + x_max}], npoints={npoints}")

        cdf_values = generate_cdf_data(mean, sigma, gamma, x_values)

        all_data[name] = {
            "mean": float(mean),
            "sigma": float(sigma),
            "gamma": float(gamma),
            "x_values": [float(x) for x in x_values],
            "cdf_values": [float(c) for c in cdf_values],
        }

        print(
            f"  CDF range: [{min(cdf_values):.10e}, {max(cdf_values):.10e}]"
        )

    # Save JSON for inspection if needed (into unit_tests/)
    json_path = out_dir / "voigt_cdf_reference.json"
    with json_path.open("w") as f:
        json.dump(all_data, f, indent=2)

    print(f"\nSaved JSON reference data to {json_path}")

    # Generate a C++ header similar to scipy_voigt_test_data.hpp
    hpp_path = out_dir / "voigt_cdf_reference.hpp"
    cpp_path = out_dir / "voigt_cdf_reference.cpp"

    cpp_header = """// Reference Voigt CDF values generated using scipy
// Generated by integrating scipy.special.voigt_profile PDF
// This file is auto-generated by unit_tests/scripts/generate_voigt_cdf_reference.py - do not edit manually

#ifndef VOIGT_CDF_REFERENCE_HPP
#define VOIGT_CDF_REFERENCE_HPP

#include <cstddef>

namespace VoigtCdfReference {
"""

    for name, data in all_data.items():
        mean = data["mean"]
        sigma = data["sigma"]
        gamma = data["gamma"]
        x_values = data["x_values"]
        cdf_values = data["cdf_values"]
        npoints = len(x_values)

        cpp_header += f"""
// Test case: {name}
// mean={mean}, sigma={sigma}, gamma={gamma}
constexpr double {name}_mean = {mean};
constexpr double {name}_sigma = {sigma};
constexpr double {name}_gamma = {gamma};
constexpr std::size_t {name}_npoints = {npoints};

extern const double {name}_x_values[{npoints}];
extern const double {name}_cdf_values[{npoints}];
"""

    cpp_header += """
} // namespace VoigtCdfReference

#endif // VOIGT_CDF_REFERENCE_HPP
"""

    with hpp_path.open("w") as f:
        f.write(cpp_header)

    # Also emit a .cpp with the actual arrays to avoid ODR issues
    cpp_impl = """// Definition of reference Voigt CDF arrays (generated)
//
// NOTE: This file is auto-generated by unit_tests/scripts/generate_voigt_cdf_reference.py
// Do not edit manually; regenerate instead if parameters or resolution change.

#include "voigt_cdf_reference.hpp"

namespace VoigtCdfReference {
"""

    for name, data in all_data.items():
        x_values = data["x_values"]
        cdf_values = data["cdf_values"]
        npoints = len(x_values)

        cpp_impl += f"""
const double {name}_x_values[{npoints}] = {{
"""
        for i, x in enumerate(x_values):
            cpp_impl += f"    {x:.15e}"
            if i < npoints - 1:
                cpp_impl += ","
            if (i + 1) % 5 == 0:
                cpp_impl += "\n"
        cpp_impl += "\n};\n\n"

        cpp_impl += f"const double {name}_cdf_values[{npoints}] = {{\n"
        for i, c in enumerate(cdf_values):
            cpp_impl += f"    {c:.15e}"
            if i < npoints - 1:
                cpp_impl += ","
            if (i + 1) % 5 == 0:
                cpp_impl += "\n"
        cpp_impl += "\n};\n\n"

    cpp_impl += "} // namespace VoigtCdfReference\n"

    with cpp_path.open("w") as f:
        f.write(cpp_impl)

    print(f"Generated C++ header and source: {hpp_path} / {cpp_path}")

