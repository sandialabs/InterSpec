/* InterSpec: an application to analyze spectral gamma radiation data.
 
 Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
 (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
 Government retains certain rights in this software.
 For questions contact William Johnson via email at wcjohns@sandia.gov, or
 alternative emails of interspec@sandia.gov.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include "InterSpec_config.h"

#include <memory>
#include <iostream>

#include <boost/math/constants/constants.hpp>
#include <boost/math/special_functions/erf.hpp>
#include <boost/math/distributions/poisson.hpp>

#include "InterSpec/PeakDef.h"
#include "InterSpec/PeakDists.h"

#include "InterSpec/PeakDists_imp.hpp"

using namespace std;


namespace PeakDists
{
  /** 20191230: wcjohns extracted the boost::math::erf() function implementation
   from boost 1.65.1 for double precision (53 bit mantissa) into this function,
   boost_erf_imp(). Removing some of the supporting code structure, and
   explicitly writing out the polynomial equation evaluation seems to speed
   things up by about a factor of ~3 over calling boost::math::erf().
   
   Using the commented out erf_approx() function looks to be about 25% faster than
   this boost version, but I havent carefully checked out the precision implications
   so not switching to it yet.
   
   Surprisingly, the erf() function is the major bottleneck for peak fitting.
   
   Another alternative is to use `Eigen::numext::erf(...)`, but it is slightly slower than
   this function, for the double case, but slightly faster if we use float
   */
  double boost_erf_imp( double z )
  {
    /* Since this function is a (slight) modification of boost source code, it
     is subject to the Boost Version 1 Software License, whose text is:
     
     Boost Software License - Version 1.0 - August 17th, 2003
     
     Permission is hereby granted, free of charge, to any person or organization
     obtaining a copy of the software and accompanying documentation covered by
     this license (the "Software") to use, reproduce, display, distribute,
     execute, and transmit the Software, and to prepare derivative works of the
     Software, and to permit third-parties to whom the Software is furnished to
     do so, all subject to the following:
     
     The copyright notices in the Software and this entire statement, including
     the above license grant, this restriction and the following disclaimer,
     must be included in all copies of the Software, in whole or in part, and
     all derivative works of the Software, unless such copies or derivative
     works are solely in the form of machine-executable object code generated by
     a source language processor.
     
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
     SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
     FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
     ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     DEALINGS IN THE SOFTWARE.
     */
    if(z < 0)
      return -boost_erf_imp( -z );
    
    if( z < 0.5 )
    {
      if( z < 1e-10 )
      {
        return z * 1.125f + z * 0.003379167095512573896158903121545171688;
      }else
      {
        const double zz = z * z;
        const double P_eval = (((zz*-0.000322780120964605683831 + -0.00772758345802133288487)*zz + -0.0509990735146777432841)*zz + -0.338165134459360935041)*zz + 0.0834305892146531832907;
        const double Q_eval = (((zz*0.000370900071787748000569 + 0.00858571925074406212772)*zz + 0.0875222600142252549554)*zz + 0.455004033050794024546)*zz + 1.0;
        
        return z * (1.044948577880859375f + P_eval / Q_eval);
      }
    }else if( z < 5.8f )
    {
      if(z < 1.5f)
      {
        static const double Y = 0.405935764312744140625f;
        static const double P[] = { -0.098090592216281240205, 0.178114665841120341155,
          0.191003695796775433986, 0.0888900368967884466578, 0.0195049001251218801359,
          0.00180424538297014223957
        };
        static const double Q[] = { 1.0, 1.84759070983002217845,
          1.42628004845511324508, 0.578052804889902404909, 0.12385097467900864233,
          0.0113385233577001411017, 0.337511472483094676155e-5
        };
        
        const double zarg = z - 0.5;
        const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
        const double Q_eval = (((((Q[6]*zarg + Q[5])*zarg + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
        
        return 1 - (Y + P_eval / Q_eval) * (exp(-z * z) / z);
      }else if(z < 2.5f)
      {
        static const double Y = 0.50672817230224609375f;
        static const double P[] = { -0.0243500476207698441272, 0.0386540375035707201728,
          0.04394818964209516296, 0.0175679436311802092299, 0.00323962406290842133584,
          0.000235839115596880717416
        };
        static const double Q[] = { 1.0, 1.53991494948552447182, 0.982403709157920235114,
          0.325732924782444448493, 0.0563921837420478160373, 0.00410369723978904575884
        };
        
        const double zarg = z - 1.5;
        const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
        const double Q_eval = ((((zarg*Q[5] + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
        
        return 1 - (Y + P_eval / Q_eval) * (exp(-z * z) / z);
      }
      else if(z < 4.5f)
      {
        static const double Y = 0.5405750274658203125f;
        static const double P[] = { 0.00295276716530971662634, 0.0137384425896355332126,
          0.00840807615555585383007, 0.00212825620914618649141, 0.000250269961544794627958,
          0.113212406648847561139e-4
        };
        static const double Q[] = { 1.0, 1.04217814166938418171,
          0.442597659481563127003, 0.0958492726301061423444, 0.0105982906484876531489,
          0.000479411269521714493907
        };
        
        const double zarg = z - 3.5;
        const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
        const double Q_eval = ((((zarg*Q[5] + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
        
        return 1 - (Y + P_eval / Q_eval) * (exp(-z * z) / z);
      }else
      {
        static const double Y = 0.5579090118408203125f;
        static const double P[] = { 0.00628057170626964891937, 0.0175389834052493308818,
          -0.212652252872804219852, -0.687717681153649930619, -2.5518551727311523996,
          -3.22729451764143718517, -2.8175401114513378771
        };
        static const double Q[] = { 1.0, 2.79257750980575282228, 11.0567237927800161565,
          15.930646027911794143, 22.9367376522880577224, 13.5064170191802889145,
          5.48409182238641741584
        };
        
        const double zarg = 1.0 / z;
        const double P_eval = (((((P[6]*zarg + P[5])*zarg + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
        const double Q_eval = (((((Q[6]*zarg + Q[5])*zarg + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
        
        return 1 - (Y + P_eval / Q_eval) * (exp(-z * z) / z);
      }
    }
    
    return 1;
  }//double boost_erf_imp( double z )
  
  
  /** 20231123: The JavaScript needed a better `erfc` implementation than just `1-erf`, or otherwise there were huge
   artifacts, and regions that just wouldnt draw, so wcjohns extracted this `erfc` function from boost; boost implements `erf`
   and `erfc` in the same function, but since the JS just needs `erfc`, wcjohns separated the erf and erf implementation, even
   though they are largely duplicate - saves some small amount of code/overhead.
   */
  double boost_erfc_imp( double z )
  {
    /* Since this function is a (slight) modification of boost source code, it
     is subject to the Boost Version 1 Software License, whose text is:
     
     Boost Software License - Version 1.0 - August 17th, 2003
     
     Permission is hereby granted, free of charge, to any person or organization
     obtaining a copy of the software and accompanying documentation covered by
     this license (the "Software") to use, reproduce, display, distribute,
     execute, and transmit the Software, and to prepare derivative works of the
     Software, and to permit third-parties to whom the Software is furnished to
     do so, all subject to the following:
     
     The copyright notices in the Software and this entire statement, including
     the above license grant, this restriction and the following disclaimer,
     must be included in all copies of the Software, in whole or in part, and
     all derivative works of the Software, unless such copies or derivative
     works are solely in the form of machine-executable object code generated by
     a source language processor.
     
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
     SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
     FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
     ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     DEALINGS IN THE SOFTWARE.
     */

    if( z < 0 )
      return (z < -0.5) ? (2 - boost_erfc_imp( -z )) : (1 + boost_erf_imp( -z ));
    
    if( z < 0.5 )
      return 1 - boost_erf_imp( z );
    
    if( z >= 28 )
      return 0;
    
    if(z < 1.5f)
    {
      static const double P[] = { -0.098090592216281240205, 0.178114665841120341155,
        0.191003695796775433986, 0.0888900368967884466578, 0.0195049001251218801359,
        0.00180424538297014223957
      };
      static const double Q[] = { 1.0, 1.84759070983002217845,
        1.42628004845511324508, 0.578052804889902404909, 0.12385097467900864233,
        0.0113385233577001411017, 0.337511472483094676155e-5
      };
      
      const double zarg = z - 0.5;
      const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
      const double Q_eval = (((((Q[6]*zarg + Q[5])*zarg + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
      
      return (0.405935764312744140625f + P_eval / Q_eval) * (exp(-z * z) / z);
    }//if(z < 1.5f)
    
    if( z < 2.5f )
    {
      static const double P[] = { -0.0243500476207698441272, 0.0386540375035707201728,
        0.04394818964209516296, 0.0175679436311802092299, 0.00323962406290842133584,
        0.000235839115596880717416
      };
      static const double Q[] = { 1.0, 1.53991494948552447182, 0.982403709157920235114,
        0.325732924782444448493, 0.0563921837420478160373, 0.00410369723978904575884
      };
      
      const double zarg = z - 1.5;
      const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
      const double Q_eval = ((((zarg*Q[5] + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
      
      return (0.50672817230224609375f + P_eval / Q_eval) * (exp(-z * z) / z);
      // Boost implementation has an additional minor error correction here
    }//if( z < 2.5f
    
    if( z < 4.5f )
    {
      static const double P[] = { 0.00295276716530971662634, 0.0137384425896355332126,
        0.00840807615555585383007, 0.00212825620914618649141, 0.000250269961544794627958,
        0.113212406648847561139e-4
      };
      static const double Q[] = { 1.0, 1.04217814166938418171,
        0.442597659481563127003, 0.0958492726301061423444, 0.0105982906484876531489,
        0.000479411269521714493907
      };
      
      const double zarg = z - 3.5;
      const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
      const double Q_eval = ((((zarg*Q[5] + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
      return (0.5405750274658203125f + P_eval / Q_eval) * (exp(-z * z) / z);
      // Boost implementation has an additional minor error correction here
    }//if( z < 4.5f )
    
    static const double P[] = { 0.00628057170626964891937, 0.0175389834052493308818,
      -0.212652252872804219852, -0.687717681153649930619, -2.5518551727311523996,
      -3.22729451764143718517, -2.8175401114513378771
    };
    static const double Q[] = { 1.0, 2.79257750980575282228, 11.0567237927800161565,
      15.930646027911794143, 22.9367376522880577224, 13.5064170191802889145,
      5.48409182238641741584
    };
    
    const double zarg = 1.0 / z;
    const double P_eval = (((((P[6]*zarg + P[5])*zarg + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
    const double Q_eval = (((((Q[6]*zarg + Q[5])*zarg + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
    
    return (0.5579090118408203125f + P_eval / Q_eval) * (exp(-z * z) / z);
    // Boost implementation has an additional minor error correction here
}//double boost_erfc_imp( double z )
  
  /*
  double erf_approx( double x )
  {
    //https://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python#answer-457805
    // Error is less than 1.5 * 10-7 for all inputs
    // (originally from Handbook of Mathematical Functions)
    const double sign = (x >= 0) ? 1 : -1;
    x = fabs(x);
    const double t = 1.0/(1.0 + 0.3275911*x);
    const double y = 1.0 - (((((1.061405429 * t + -1.453152027) * t) + 1.421413741) * t + -0.284496736) * t + 0.254829592) * t * std::exp(-x * x);
    return sign * y;
  }
   */
  

// Explicit instantiation definition for the `double` version of `photopeak_function_integral(...)`
template void photopeak_function_integral<double>( const double, const double,const double,
                         const PeakDef::SkewType, const double * const, const size_t, const float * const, double * );

  
  /** Returns the PDF for a unit-area Bortel function.
   */
  double bortel_pdf( const double mean, const double sigma, const double skew_low, const double x )
  {
    // 32-bit floats have a normalized range of 1E-38 to 1E38; 64bit floats 1E-308 to 1E308
    // We could use the proper functions up to ~1E308, but to be conservative, but to be
    // a little conservative, we'll switch to using a gaussian when the exp() and erfc()
    // functions start returning values with limits near 1E-38 or 1E38.
    // Although difference between the methods will start out ar ~30% and increase to >100%,
    // the function values are so small, they dont really matter.
    // TODO: try expanding the function, around (or above) `mean` to see if there can be a better approximation
    
    const double exp_arg = ((x - mean)/skew_low) + (sigma*sigma/(2*skew_low*skew_low));
    const double erfc_arg = 0.7071067812*(((x - mean)/sigma) + (sigma/skew_low));
    
    if( (skew_low <= 0.0) || (exp_arg > 87.0) || (erfc_arg > 10.0) )
    {
      const double a = (x-mean)/sigma;
      return (1.0/(sigma*2.5066282746)) * std::exp( -0.5 * a*a );
    }
    
    return (0.5/skew_low)*std::exp( exp_arg ) * boost_erfc_imp( erfc_arg );
  }//double bortel_pdf(...)


  // Explicit instantiation definition for the `double` version of `bortel_indefinite_integral(...)`
  template double bortel_indefinite_integral<double>( const double, const double,
                                                            const double, const double );

  
  double bortel_integral( const double mean, const double sigma, const double skew,
                         const double x1, const double x2 )
  {
    return bortel_indefinite_integral(x2, mean, sigma, skew )
      - bortel_indefinite_integral(x1, mean, sigma, skew );
  }

  /** Returns an approximate area between `x1` and `x2` for a unit-area Bortel function.
   
   Just multiplies the x-range by the Bortel PDF value in the middle of the range.
   */
  double bortel_integral_fast( const double mean, const double sigma, const double skew,
                              const double x1, const double x2 )
  {
    const double half_way_x = 0.5*(x1 + x2);
    return (x2 - x1) * bortel_pdf( mean, sigma, skew, half_way_x );
  }
  
  
  std::pair<double,double> bortel_coverage_limits( const double mean, const double sigma,
                                         const double skew, const double p )
  {
    if( (p <= 1.0E-11) || (p > 0.999)  ) // 7 sigma would be 1.279812544E-12, so to account for skew
      throw runtime_error( "bortel_coverage_limits: invalid p" );
    
    try
    {
      auto tail_cdf = [mean,sigma,skew,p]( const double x ) -> double {
        const double cdf = bortel_indefinite_integral( x, mean, sigma, skew );
        const double answer = -0.5*p + (cdf + 0.5);
        return answer;
      };
      
      auto term_condition = [p]( const double left, const double right ) -> bool {
        return fabs(left - right) < 0.01*p;
      };
      
      boost::uintmax_t max_iter = 100;
      const double low_low_limit = mean - 50*sigma;  //50 sigma is arbitrary
      const double low_up_limit = mean - skew*sigma;
      const pair<double,double> lower_val = boost::math::tools::bisect( tail_cdf, low_low_limit,
                                                          low_up_limit, term_condition, max_iter );
      const double lower_x = 0.5*(lower_val.first + lower_val.second);
      
      
      auto upper_cdf = [mean,sigma,skew,p]( const double x ) -> double {
        const double cdf = bortel_indefinite_integral( x, mean, sigma, skew );
        return 0.5*p + (-0.5 + cdf);
      };
       
      max_iter = 100;
      const double up_low_limit = mean;
      const double up_up_limit = mean + 7*sigma;
      const pair<double,double> upper_val = boost::math::tools::bisect( upper_cdf, up_low_limit,
                                                          up_up_limit, term_condition, max_iter );
      const double upper_x = 0.5*(upper_val.first + upper_val.second);
        
      assert( (1.0 - bortel_integral(mean, sigma, skew, lower_val.first, upper_val.second)) <= (p + 1.0E-6) );
      assert( (1.0 - bortel_integral(mean, sigma, skew, lower_val.second, upper_val.first)) >= (p - 1.0E-6) );
      
      return pair<double,double>( lower_x, upper_x );
    }catch( std::exception &e )
    {
      throw runtime_error( "bortel_coverage_limits: failed to find limit: " + string(e.what()) );
    }//try / catch
    
    assert( 0 );
    return std::pair<double,double>( -1.0, -1.0 );
  }//bortel_coverage_limits(...)
  
  
  std::pair<double,double> gauss_exp_coverage_limits( const double mean, const double sigma,
                                         const double skew, const double p )
  {
    const double root_two = boost::math::constants::root_two<double>();
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    
    const double norm = gauss_exp_norm(sigma,skew);
    const double tail_norm = norm * (sigma / skew);
    
    const double indefinite_of_tail = tail_norm * std::exp( -0.5*skew*skew );
    const double erf_neg_skew = boost_erf_imp(-skew*one_div_root_two);
    const double gaus_norm = norm * sigma * root_half_pi;
    
    if( (p <= 1.0E-11) || (p > 0.999)  ) // for gaussian, 7 sigma would be 1.279812544E-12
      throw runtime_error( "gauss_exp_coverage_limits: invalid p" );
    
    try
    {
      auto x_from_eqn = [mean, sigma, skew, tail_norm, indefinite_of_tail, root_two, erf_neg_skew, gaus_norm]( const double prob ) -> double {
        if( prob <= indefinite_of_tail )
        {
          const double t_eqn = (1/skew)*log(prob/tail_norm) - 0.5*skew;
          return t_eqn*sigma + mean;
        }
        
        // TODO: check that boost::math::erf_inv(double) doesnt iterate to find a precise enough
        //       solution, but if it does, maybe try using boost::math::policies::policy<boost::math::policies::digits10<8> >
        const double t_eqn = root_two * boost::math::erf_inv( erf_neg_skew + (prob - indefinite_of_tail)/gaus_norm );
        return t_eqn*sigma + mean;
      };//auto x_from_eqn
      
      const double lower_x = x_from_eqn( 0.5*p );
      const double upper_x = x_from_eqn( 1.0 - 0.5*p );
        
      if( IsNan(lower_x) || IsInf(lower_x) || IsNan(upper_x) || IsInf(upper_x) )
        throw runtime_error( "got invalid answer" );
      
      assert( (1.0 - gauss_exp_integral( mean, sigma, skew, lower_x, upper_x)) <= (p + 1.0E-6) );
        
      return pair<double,double>( lower_x, upper_x );
    }catch( std::exception &e )
    {
      throw runtime_error( "gauss_exp_coverage_limits: failed to find limit: " + string(e.what()) );
    }//try / catch
    
    assert( 0 );
    return std::pair<double,double>( -1.0, -1.0 );
  }//gauss_exp_coverage_limits(...)
  
  
  std::pair<double,double> exp_gauss_exp_coverage_limits( const double mean, const double sigma,
                                const double left_skew, const double right_skew, const double p )
  {
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    const double root_half_pi = boost::math::constants::root_half_pi<double>(); //1.2533141373155002512078826424
    
    const double norm = exp_gauss_exp_norm( sigma, left_skew, right_skew );
    const double left_tail_norm = norm*(sigma/left_skew);
    const double right_tail_norm = norm*(sigma / right_skew);
    const double rtail_constant = std::exp(-right_skew*right_skew/2);
    const double gaus_constant = norm * sigma * root_half_pi;
    const double erf_left_skew = boost_erf_imp( -one_div_root_two*left_skew );
    
    const double indef_at_left_skew = left_tail_norm*std::exp( -0.5*left_skew*left_skew );
    const double indef_at_right_skew = indef_at_left_skew + gaus_constant * (boost_erf_imp( one_div_root_two*right_skew ) - erf_left_skew );
    
    
    if( (p <= 1.0E-11) || (p > 0.999)  ) // for gaussian, 7 sigma would be 1.279812544E-12
      throw runtime_error( "exp_gauss_exp_coverage_limits: invalid p" );
    
    try
    {
      auto x_from_eqn = [indef_at_right_skew,indef_at_left_skew,left_skew,left_tail_norm,mean,sigma,
                         one_div_root_two,erf_left_skew,gaus_constant,right_skew,right_tail_norm,rtail_constant]( const double prob ) -> double {
        if( prob <= indef_at_left_skew )
        {
          const double t_eqn = -0.5*left_skew  + log(prob/left_tail_norm)/left_skew;
          return t_eqn*sigma + mean;
        }
        
        if( prob < indef_at_right_skew )
        {
          const double t_eqn = boost::math::erf_inv( (prob - indef_at_left_skew + gaus_constant*erf_left_skew)/gaus_constant )/one_div_root_two;
          return t_eqn*sigma + mean;
        }
        
        const double t_eqn = 0.5*right_skew - log(rtail_constant - (prob - indef_at_right_skew)/right_tail_norm)*(1/right_skew);
        return t_eqn*sigma + mean;
      };//auto x_from_eqn
      
      
      const double lower_x = x_from_eqn( 0.5*p );
      const double upper_x = x_from_eqn( 1.0 - 0.5*p );
      
      if( IsNan(lower_x) || IsInf(lower_x) || IsNan(upper_x) || IsInf(upper_x) )
        throw runtime_error( "got invalid answer" );
      
      assert( (1.0 - exp_gauss_exp_integral( mean, sigma, left_skew, right_skew, lower_x, upper_x)) <= (p + 1.0E-6) );
      
      return pair<double,double>( lower_x, upper_x );
    }catch( std::exception &e )
    {
      throw runtime_error( "exp_gauss_exp_coverage_limits: failed to find limit: " + string(e.what()) );
    }//try / catch
    
    assert( 0 );
    return std::pair<double,double>( -1.0, -1.0 );
  }//exp_gauss_exp_coverage_limits(...)
  
  
  
  std::pair<double,double> crystal_ball_coverage_limits( const double mean, const double sigma,
                                                        const double alpha,
                                                        const double n,
                                                        const double p )
  {
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    const double sqrt_2pi = boost::math::constants::root_two_pi<double>();
    
    const double A = std::pow(n/alpha, n) * std::exp( -0.5*alpha*alpha );
    const double B = (n / alpha) - alpha;
    const double C = (n / alpha) * (1.0/(n - 1.0)) * std::exp( -0.5*alpha*alpha );
    const double D = root_half_pi * (1.0 + boost_erf_imp( one_div_root_two * alpha ));
    const double N = 1.0 / (sigma * (C + D));
    const double tail_norm = N * A * sigma / (n - 1.0);
    const double gauss_indef_amp = 0.5 * sqrt_2pi / (C + D);
    const double gaus_indef_at_skew = gauss_indef_amp * boost_erf_imp( -alpha*one_div_root_two );
    const double indefinite_of_tail = tail_norm * std::pow( B + alpha, 1.0 - n );
    
    if( (p <= 1.0E-11) || (p > 0.999)  ) // for gaussian, 7 sigma would be 1.279812544E-12
      throw runtime_error( "crystal_ball_coverage_limits: invalid p" );
    
    try
    {
      auto x_from_eqn = [tail_norm,indefinite_of_tail,B,n,one_div_root_two,sigma,mean,
                         gauss_indef_amp,gaus_indef_at_skew]( const double prob ) -> double {
        if( prob < indefinite_of_tail )
        {
          const double t_eqn = B - std::pow( prob/tail_norm, 1.0/(1.0 - n));
          return t_eqn*sigma + mean;
        }
        
        const double root_two = boost::math::constants::root_two<double>(); //1.414213562373095048801688724209698078
        const double t_eqn = root_two* boost::math::erf_inv( (1.0/gauss_indef_amp) * (prob - indefinite_of_tail + gaus_indef_at_skew) );
        return t_eqn*sigma + mean;
      };//auto x_from_eqn
      
      const double lower_x = x_from_eqn( 0.5*p );
      const double upper_x = x_from_eqn( 1.0 - 0.5*p );
      
      if( IsNan(lower_x) || IsInf(lower_x) || IsNan(upper_x) || IsInf(upper_x) )
        throw runtime_error( "got invalid answer" );
      
      assert( (1.0 - crystal_ball_integral(mean, sigma, alpha, n, lower_x, upper_x)) <= (p + 1.0E-6) );
      
      return pair<double,double>( lower_x, upper_x );
    }catch( std::exception &e )
    {
      throw runtime_error( "crystal_ball_coverage_limits: failed to find limit: " + string(e.what()) );
    }//try / catch
    
    assert( 0 );
    return std::pair<double,double>( -1.0, -1.0 );
  }//crystal_ball_coverage_limits(...)
  
  
  std::pair<double,double> double_sided_crystal_ball_coverage_limits( const double mean, const double sigma,
                                                                     const double left_skew,
                                                                     const double left_n,
                                                                     const double right_skew,
                                                                     const double right_n,
                                                                     const double p )
  {
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    const double root_half_pi = boost::math::constants::root_half_pi<double>(); //1.2533141373155002512078826424
    
    const double norm = DSCB_norm( left_skew, left_n, right_skew, right_n );
    const double exp_lower_aa = std::exp(-0.5*left_skew*left_skew);
    const double exp_upper_aa = std::exp(-0.5*right_skew*right_skew);

    const double right_tail_indef_at_rskew = norm * exp_upper_aa*(1.0 / ((right_skew / right_n) - right_skew)); //this is the indefinete integral evaluation at `right_skew`.

    auto left_tail_indefinite_t = [left_skew, left_n, norm, exp_lower_aa]( const double t ) -> double {
      const double t_1 = (t == -left_skew) ? 1.0 : 1.0 - (left_skew / (left_n / (left_skew + t)));
      return -norm * exp_lower_aa * (t_1 / std::pow(t_1, left_n)) / ((left_skew / left_n) - left_skew); //slightly more stable
    };
    
    
    auto right_tail_area_t = [right_skew, right_n, norm, exp_upper_aa, right_tail_indef_at_rskew]( const double t ) -> double {
      const double t_1 = (t == right_skew) ? 1.0 : (1.0 + ((right_skew * (t - right_skew)) / right_n));
      const double answer = norm * exp_upper_aa*(1.0 / ((right_skew / right_n) - right_skew)) * std::pow(t_1, (1.0 - right_n)) - right_tail_indef_at_rskew;

#if( PERFORM_DEVELOPER_CHECKS && !defined(NDEBUG) )
      //Not quite as stable version
      const double indef = (norm*(right_n * exp(-0.5*right_skew*right_skew) * pow((right_skew * (t - right_skew) + right_n) / right_n,1 - right_n)) / ((1 - right_n) * right_skew));
      assert( fabs((indef - right_tail_indef_at_rskew) - answer) < 1.0E-5*norm );
#endif

      return answer;
    };
    
    assert( fabs(right_tail_area_t(right_skew)) < 1.E-8 );

    const double gaus_indef_at_left_skew = norm * root_half_pi * boost_erf_imp( -left_skew * one_div_root_two );
    auto gauss_indefinite_t = [norm, gaus_indef_at_left_skew, one_div_root_two, root_half_pi]( const double t ) -> double {
      return norm * root_half_pi * boost_erf_imp( one_div_root_two * t ) - gaus_indef_at_left_skew;
    };
    
    const double indef_at_left_skew = left_tail_indefinite_t( -left_skew );
    const double indef_at_right_skew = indef_at_left_skew + gauss_indefinite_t( right_skew );


#if( PERFORM_DEVELOPER_CHECKS && !defined(NDEBUG) )
    const auto rindef_t = [=]( const double t ){
      return norm*(right_n * exp(-0.5*right_skew*right_skew) * pow((right_skew * (t - right_skew) + right_n) / right_n,1 - right_n)) / ((1 - right_n) * right_skew);
    };
    const double check_indef_right = rindef_t( right_skew );
    assert( fabs(check_indef_right - right_tail_indef_at_rskew) < 1.E-12 );

    const double check_indef_right_2 = norm*DSCB_right_tail_indefinite_non_norm_t( right_skew, right_n, right_skew );
    assert( fabs(check_indef_right_2 - right_tail_indef_at_rskew) < 1.E-6*norm );

    const double expected_left_indef = norm*(left_n * exp(-0.5*left_skew*left_skew)) / ((left_n - 1) * left_skew);
    assert( fabs(indef_at_left_skew - expected_left_indef) < 1.0E-6 );
    const double expected_gaus_area = norm*root_half_pi * (std::erf(left_skew*one_div_root_two) + std::erf(right_skew*one_div_root_two));
    const double expected_right_indef = expected_left_indef + expected_gaus_area;
    assert( fabs(expected_right_indef - indef_at_right_skew) < 1.0E-6 );

    const double rtail_area = right_tail_area_t( 1.0E32 );


    const double rtail_area_exp = norm*(DSCB_right_tail_indefinite_non_norm_t( right_skew, right_n, 1.0E32 ) - DSCB_right_tail_indefinite_non_norm_t( right_skew, right_n, right_skew ));
    assert( fabs(rtail_area - rtail_area_exp) < 1.0E-3 );
#endif

    auto indefinite_x = [mean, sigma, left_skew, right_skew,
                       left_tail_indefinite_t, right_tail_area_t, gauss_indefinite_t,
                       indef_at_left_skew, indef_at_right_skew]( const double x ) {
      const double t = (x - mean) / sigma;
      if( t <= -left_skew )
        return left_tail_indefinite_t( t );
      
      if( t <= right_skew )
        return indef_at_left_skew + gauss_indefinite_t( t );

      const double right_frac = right_tail_area_t( t );

      return indef_at_right_skew + right_frac;
    };
    
    
    auto lower_fcn = [mean, sigma, left_skew, right_skew, p, indefinite_x]( const double x ) -> double {
      return -0.5*p + indefinite_x( x );
    };
    
    auto upper_fcn = [mean, sigma, left_skew, right_skew, p, indefinite_x]( const double x ) -> double {
      return -0.5*p + (1.0 - indefinite_x( x ));
    };
    
    if( (p <= 1.0E-11) || (p > (1.0 - 1.0E-11))  ) // for gaussian, 7 sigma would be 1.279812544E-12
      throw runtime_error( "double_sided_crystal_ball_coverage_limits: invalid p" );
    
    auto x_from_eqn = [mean, sigma, norm, left_skew, left_n, right_skew, right_n,
                       indef_at_left_skew, indef_at_right_skew, gaus_indef_at_left_skew,
                       right_tail_indef_at_rskew, exp_lower_aa, exp_upper_aa, root_half_pi ]( const double prob ) -> double {
      if( prob <= indef_at_left_skew )
      {
        // TODO: these next lines could probably be way simplified and improved
        const double tmp = std::pow( -prob * ((left_skew / left_n) - left_skew) / (norm * exp_lower_aa), 1.0/(1-left_n));
        const double t_eqn = -left_skew + left_n*((1.0 - tmp)/left_skew);
        return t_eqn*sigma + mean;
      }
      
      if( prob < indef_at_right_skew )
      {
        const double root_two = boost::math::constants::root_two<double>();
        const double t_eqn = root_two * boost::math::erf_inv( (prob - indef_at_left_skew + gaus_indef_at_left_skew) / (norm * root_half_pi) );
        return t_eqn*sigma + mean;
      }


      const double remaining_prob = prob - indef_at_right_skew;
      //remaining_prob == (right_tail_indef(t) - right_tail_indef(right_skew))
      //remaining_prob = right_tail_indef(t) - right_tail_indef(right_skew)
      //remaining_prob = right_tail_indef(t) - right_tail_indef_at_rskew
      //remaining_prob + right_tail_indef_at_rskew = right_tail_indef(t)
      //remaining_prob + right_tail_indef_at_rskew
      //        = norm*(exp_upper_aa*right_n*std::pow((right_skew*(t + right_n/right_skew - right_skew))/right_n,1-right_n))/(right_skew*(1-right_n))
      //(right_skew*(1-right_n)*(remaining_prob + right_tail_indef_at_rskew)/(norm*exp_upper_aa*right_n)
      //              = (std::pow((right_skew*(t + right_n/right_skew - right_skew))/right_n,1-right_n)))
      // Set left side equal to A
      // A = std::pow((right_skew*(t + right_n/right_skew - right_skew))/right_n,1-right_n)))
      //... put int chatGPT ...
      const double A = (right_skew*(1-right_n))*(remaining_prob + right_tail_indef_at_rskew)/(norm*exp_upper_aa*right_n);
      const double t_eqn = (right_n*pow(A,1.0/(1-right_n))/right_skew) - (right_n/right_skew) + right_skew;
      const double x = t_eqn*sigma + mean;

      if( IsInf(x) || IsNan(x) )
        throw runtime_error("failed to symbolically solve");

      return x;
    };//auto x_from_eqn
    
    
    try
    {
      auto term_condition = [p]( const double left, const double right ) -> bool {
        return fabs(left - right) < 0.01*p;
      };

      // TODO: if value is in right tail, we will fail, in which case we will resort to an iterative solution
      double lower_x = -999, upper_x = -999;
      try
      {
        lower_x = x_from_eqn( 0.5*p );
      }catch( std::exception & )
      {
        cout << "Failed to find lower answer by eqn from p=" << p << endl;
      }
      
      try
      {
        upper_x = x_from_eqn( 1.0 - 0.5*p );
      }catch( std::exception & )
      {
        // Add a reminder here so we eventually fix not being able to get p-value from upper tail
        static std::atomic<size_t> ntimeshere = 0;
        if( (++ntimeshere < 25) || ((ntimeshere%100) == 0) )
          cerr << "Failed to find upper answer by eqn from p=" << p << endl;
      }
      

      if( (lower_x < -998) || IsNan(lower_x) || IsInf(lower_x) )
      {
        // With huge skew and/or small probabilities, the energy-value we are looking for can be
        //  really far away from mean, so we will search by doubling the search range.
        double low_low_limit;
        bool found_lower = false;
        const size_t max_range_doublings = 40;
        double current_dx = 20.0 * std::max(sigma, 0.1); //20 sigma starting is arbitrary
        for( size_t i = 0; !found_lower && (i < max_range_doublings); ++i, current_dx *= 2 )
        {
          low_low_limit = mean - current_dx;
          const double y = lower_fcn( low_low_limit );
          found_lower = (y < 0.0);
        }//for( look for x where pdf has gone below limit )
        
        // If we didnt find the lower limit, `boost::math::tools::bisect(...)` will throw exception
        //assert( found_lower );
        
#if( PERFORM_DEVELOPER_CHECKS )
        if( !found_lower )
        {
          const string msg = "Failed to find lower limit by " + std::to_string(mean - current_dx)
          + " for double_sided_crystal_ball_coverage_limits( "
          + std::to_string(mean) + ", " + std::to_string(sigma) + ", " + std::to_string(left_skew)
          + ", " + std::to_string(left_n) + ", " + std::to_string(right_skew) + ", "
          + std::to_string(right_n) + ", " + std::to_string(p) + " )."
          "  lower_fcn(" + std::to_string(low_low_limit) + ")=" + std::to_string( lower_fcn(low_low_limit) ) + ")";

          log_developer_error( __func__, msg.c_str() );
        }//if( !found_upper )
#endif
        
        boost::uintmax_t max_iter = 1000;
        const pair<double,double> lower_val = boost::math::tools::bisect( lower_fcn, low_low_limit,
                                                                         mean, term_condition, max_iter );
        lower_x = 0.5*(lower_val.first + lower_val.second);
      }//if( lower_x < 989 || IsNan(lower_x) || IsInf(lower_x) )
      
       
      if( (upper_x < -998) || IsNan(upper_x) || IsInf(upper_x) )
      {
        // With huge skew and/or small probabilities, the energy-value we are looking for can be
        //  really huge, so we will search by doubling the search range.
        double up_up_limit;
        bool found_upper = false;
        const size_t max_range_doublings = 40;
        double current_dx = 20.0 * std::max(sigma, 0.1);
        for( size_t i = 0; !found_upper && (i < max_range_doublings); ++i, current_dx *= 2 )
        {
          up_up_limit = mean + current_dx;
          const double y = upper_fcn( up_up_limit );
          found_upper = (y < 0.0);
        }//for( look for x where pdf has gone below limit )
        
        // If we didnt find the upper limit, `boost::math::tools::bisect(...)` will throw exception
        //assert( found_upper );
        
#if( PERFORM_DEVELOPER_CHECKS )
        if( !found_upper )
        {
          const double y_mean_2sigma = upper_fcn( mean + 2*sigma );
          const double y_mean_5sigma = upper_fcn( mean + 5*sigma );
          const double y_mean_10sigma = upper_fcn( mean + 10*sigma );
          const double y_mean_20sigma = upper_fcn( mean + 20*sigma );
          const double y_mean_40sigma = upper_fcn( mean + 40*sigma );
          
          const string msg = "Failed to find upper limit by " + std::to_string(mean + current_dx)
          + " for\n"
          "\tdouble_sided_crystal_ball_coverage_limits( mean="
          + std::to_string(mean) + ", sigma=" + std::to_string(sigma) + ", lskew=" + std::to_string(left_skew)
          + ", lpow=" + std::to_string(left_n) + ", rskew=" + std::to_string(right_skew) + ", rpow="
          + std::to_string(right_n) + ", " + std::to_string(p) + " )"
          + string("\n\ty(mean+2sigma) = ") + std::to_string(y_mean_2sigma)
          + string("\n\ty(mean+5sigma) = ") + std::to_string(y_mean_5sigma)
          + string("\n\ty(mean+10sigma) = ") + std::to_string(y_mean_10sigma)
          + string("\n\ty(mean+20sigma) = ") + std::to_string(y_mean_20sigma)
          + string("\n\ty(mean+40sigma) = ") + std::to_string(y_mean_40sigma)
          ;
          
          log_developer_error( __func__, msg.c_str() );
        }//if( !found_upper )
#endif

        boost::uintmax_t max_iter = 1000;
        const pair<double,double> upper_val = boost::math::tools::bisect( upper_fcn, mean,
                                                                         up_up_limit, term_condition, max_iter );
        upper_x = 0.5*(upper_val.first + upper_val.second);
      }//if( upper_x < 989 || IsNan(upper_x) || IsInf(upper_x) )
        
      
      if( IsNan(lower_x) || IsInf(lower_x) || IsNan(upper_x) || IsInf(upper_x) )
        throw runtime_error( "got inf or NaN value" );
      
      
      return pair<double,double>( lower_x, upper_x );
    }catch( std::exception &e )
    {
      const string excmsg = e.what();
      throw runtime_error( "double_sided_crystal_ball_coverage_limits: failed to find limit: " + excmsg );
    }//try / catch
    
    assert( 0 );
    return std::pair<double,double>( -1.0, -1.0 );
  }//double_sided_crystal_ball_coverage_limits(...)
  
  
  double crystal_ball_norm( const double sigma,
                           const double alpha,
                           const double n )
  {
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>();
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    
    const double C = (n / alpha) * (1.0/(n - 1.0)) * std::exp( -0.5*alpha*alpha );
    const double D = root_half_pi * (1.0 + boost_erf_imp( one_div_root_two * alpha ));
    const double N = 1.0 / (sigma * (C + D));
    
    return N;
  }
  
  double crystal_ball_pdf(const double mean,
                          const double sigma,
                          const double alpha,
                          const double n,
                          const double x )
  {
    // From https://en.wikipedia.org/wiki/Crystal_Ball_function
    assert( alpha > 0.0 );
    if( alpha <= 0.0 )
      throw runtime_error( "crystal_ball_pdf: alpha must be >0" );
    
    assert( n > 1.0 );
    if( n <= 1.0 )
      throw runtime_error( "crystal_ball_pdf: power-law must be >1" );
    
    const double N = crystal_ball_norm( sigma, alpha, n );
    const double t = (x - mean) / sigma;
    
    if( t <= -alpha )
    {
      const double A = std::pow( n/alpha, n) * std::exp( -0.5*alpha*alpha );
      const double B = (n / alpha) - alpha;
      return N*A*std::pow( B - t, -n );
    }
    
    return N * std::exp( -0.5*t*t );
  }//crystal_ball_pdf


  /** Returns indefinite integral (negative infinite to `x0` for the power-law component for the unit-area Crystal Ball function.
   */
  double crystal_ball_tail_indefinite_t( const double sigma,
                                          const double alpha,
                                          const double n,
                                          const double t )
  {
    // TODO: this is just a niave implementation - still needs to be optimized
    // The CERN ROOT implementation switches to a log-version of this integral when `n` is
    //  less than 1 + 1E-5 - which makes sense, but for the moment lets just avoid n approaching 1
    assert( t <= -alpha );
    assert( alpha > 0.0 );
    assert( n > 1.0 );
    
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.7071....
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    
    const double A = std::pow(n/alpha, n) * std::exp( -0.5*alpha*alpha );
    const double B = (n / alpha) - alpha;
    const double C = (n / alpha) * (1.0/(n - 1.0)) * std::exp( -0.5*alpha*alpha );
    const double D = root_half_pi * (1.0 + boost_erf_imp( one_div_root_two * alpha ));
    const double N = 1.0 / (sigma * (C + D));
    
    return N * A * sigma * std::pow( B - t, 1.0 - n ) / (n - 1.0);
  }//crystal_ball_tail_indefinite_t

  /*
  double DSCB_pdf_non_norm( const double mean, const double sigma,
                            const double alpha_low, const double n_low,
                            const double alpha_high, const double n_high,
                            const double x )
  {
    // From chapter 6 of https://arxiv.org/pdf/1606.03833.pdf
    double t = (x - mean) / sigma;
    
    if( (t >= -alpha_low) && (t <= alpha_high) ) //Return gaussian value
      return std::exp(-0.5*t*t);
    
    // Return tail value
    const double n = (t > 0.0) ? n_high : n_low;
    const double alpha = (t > 0.0) ? alpha_high : alpha_low;
    t = (t > 0.0) ? -t : t;
    
    //return std::exp(-0.5*alpha*alpha) * std::pow( (alpha/n)*((n/alpha) - alpha - t), -n );
    return std::exp(-0.5*alpha*alpha) * std::pow((1.0 - ((alpha + t) * (alpha / n))), -n); //slightly more stable version of above
  }
   */

  // Explicit instantiation definition for the `double` version of `DSCB_norm(...)`
  template double DSCB_norm<double>( const double, const double, const double, const double );
  
  
  double DSCB_left_tail_indefinite_non_norm_t( const double alpha_low,
                                                          const double n_low,
                                                          const double t)
  {
    // Takes `t = (x - mean) / sigma`, not x
    assert( t <= -alpha_low );
    
    const double &a = alpha_low;
    const double &n = n_low;
    //return -(std::exp(-a*a/2)*n*std::pow((a*(-t+n/a-a))/n, 1-n))/(a*(1-n));
    const double t_1 = 1.0 - (a / (n / (a + t)));
    return -std::exp(-0.5*a*a)*(t_1 / std::pow(t_1, n)) / ((a / n) - a); //slightly more stable
  }//double DSCB_left_tail_indefinite_non_norm_t(t)
  
  
  double DSCB_right_tail_indefinite_non_norm_t( const double alpha_high,
                                                           const double n_high,
                                                           const double t)
  {
    // Takes `t = (x - mean) / sigma`, not x
    assert( (t + 1.0E-7) >= alpha_high );
    
    const double &a = alpha_high;
    const double &n = n_high;
    
    // (e^(a^2/2)*n*((a*(t+n/a-a))/n)^(1-n))/(a*(1-n))
    //return (std::exp(-a*a/2)*n*std::pow((a*(t + n/a - a))/n,1-n))/(a*(1-n));
    return std::exp(-a*a/2)*(1.0 / ((a / n) - a)) * std::pow((1.0 + ((a * (t - a)) / n)), (1.0 - n));
  }
  
  double DSCB_gauss_indefinite_non_norm_t( const double t )
  {
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
    
    return root_half_pi * boost_erf_imp( one_div_root_two * t );
  }//DSCB_gauss_indefinite_non_norm_t(...)

  
  
  // Explicit instantiation definition for the `double` version of `gaussian_integral(...)`
  template double gauss_exp_norm<double>( const double, const double );
  
  double gauss_exp_pdf(const double mean,
                       const double sigma,
                       const double skew,
                       const double x )
  {
    const double t = (x - mean) / sigma;
    const double norm = gauss_exp_norm( sigma, skew );
    if( t >= -skew )
      return norm * std::exp( -0.5*t*t );
    return norm * std::exp( 0.5*skew*skew + skew*t );
  }
  
  double gauss_exp_tail_indefinite(const double mean,
                                  const double sigma,
                                  const double skew,
                                  const double x )
  {
    const double t = (x - mean) / sigma;
    assert( t <= skew );
    
    return gauss_exp_norm(sigma,skew)*(sigma/skew)*std::exp((skew/sigma)*(0.5*skew*sigma - mean + x));
  }
  
  double gauss_exp_indefinite(const double mean,
                             const double sigma,
                             const double skew,
                             const double x )
  {
    const double t = (x - mean) / sigma;
    
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    
    double answer = gauss_exp_tail_indefinite( mean, sigma, skew, std::min(x,-skew*sigma + mean) );
    if( t >= -skew )
      answer += gauss_exp_norm(sigma,skew)*sigma*root_half_pi
                 * (boost_erf_imp(t*one_div_root_two) - boost_erf_imp(-skew*one_div_root_two) );
    return answer;
  }
  
  
  double gauss_exp_integral( const double mean, const double sigma, const double skew, const double x1, const double x2 )
  {
    return gauss_exp_indefinite(mean, sigma, skew, x2) - gauss_exp_indefinite(mean, sigma, skew, x1);
  }
      
  
  // Explicit instantiation definition for the `double` version of `exp_gauss_exp_norm(...)`
  template double exp_gauss_exp_norm<double>( const double, const double, const double );

  
  double exp_gauss_exp_pdf( const double mean,
                           const double sigma,
                           const double skew_left,
                           const double skew_right,
                           const double x )
  {
    const double t = (x - mean) / sigma;
    const double norm = exp_gauss_exp_norm( sigma, skew_left, skew_right );
    if( t > skew_right )
      return norm*std::exp( 0.5*skew_right*skew_right - skew_right*t );
    
    if( t > -skew_left )
      return norm*std::exp( -0.5*t*t );
      
    return norm*std::exp( 0.5*skew_left*skew_left + skew_left*t );
  }//double exp_gauss_exp_pdf(...)
  

  double exp_gauss_exp_left_tail_indefinite( const double mean,
                                          const double sigma,
                                          const double skew_left,
                                          const double skew_right,
                                          const double x )
  {
    //const double t = (x - mean) / sigma;
    const double norm = exp_gauss_exp_norm(sigma,skew_left,skew_right);
    return norm*(sigma/skew_left)*std::exp((skew_left/sigma)*(0.5*skew_left*sigma - mean + x));
  }

  double exp_gauss_exp_right_tail_indefinite( const double mean,
                                           const double sigma,
                                           const double skew_left,
                                           const double skew_right,
                                           const double x )
  {
    const double norm = exp_gauss_exp_norm( sigma, skew_left, skew_right );
    const double &k = skew_right;
    const double &s = sigma;
    const double &m = mean;
    return norm*((std::exp(-k*k/2)*s)/k-(s*std::exp((k*m)/s-(x*k)/s+k*k/2))/k);
  }

  double exp_gauss_exp_gauss_indefinite( const double mean,
                                      const double sigma,
                                      const double skew_left,
                                      const double skew_right,
                                      const double x )
  {
    static const double sqrt_pi = boost::math::constants::root_pi<double>(); //1.7724538509055160272981
    static const double root_half_pi = boost::math::constants::root_half_pi<double>(); //1.2533141373155002512078826424
    static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    
    const double t = (x - mean) / sigma;
    const double norm = exp_gauss_exp_norm( sigma, skew_left, skew_right);
    
    return norm * sigma * root_half_pi * (boost_erf_imp( one_div_root_two*t )
                                          - boost_erf_imp( -one_div_root_two*skew_left ) );
  }//
  
  double exp_gauss_exp_indefinite( const double mean,
                                const double sigma,
                                const double skew_left,
                                const double skew_right,
                                const double x )
  {
    const double t = (x - mean) / sigma;
    double answer = exp_gauss_exp_left_tail_indefinite( mean, sigma, skew_left, skew_right, min(x,-skew_left*sigma + mean) );
    
    if( t > skew_right )
      answer += exp_gauss_exp_right_tail_indefinite( mean, sigma, skew_left, skew_right, x );
    
    if( t > -skew_left )
      answer += exp_gauss_exp_gauss_indefinite( mean, sigma, skew_left, skew_right, min(x,skew_right*sigma + mean) );
    
    return answer;
  }
  
  double exp_gauss_exp_integral(const double mean,
                           const double sigma,
                           const double skew_left,
                           const double skew_right,
                           const double x0,
                           const double x1 )
  {
    return exp_gauss_exp_indefinite(mean, sigma, skew_left, skew_right,x1)
        - exp_gauss_exp_indefinite(mean, sigma, skew_left, skew_right, x0);
  }
  
  
  double gaussian_integral( const double peak_mean, const double peak_sigma,
                            const double x0, const double x1 )
  {
    if( peak_sigma == 0.0 )
      return 0.0;

    const double sqrt2 = boost::math::constants::root_two<double>();  //M_SQRT2 (but need to use '#define _USE_MATH_DEFINES' before #include <cmath>)
    
    const double erflowarg = (x0 - peak_mean)/(sqrt2*peak_sigma);
    const double erfhigharg = (x1 - peak_mean)/(sqrt2*peak_sigma);
    
    return 0.5 * (boost_erf_imp(erfhigharg) - boost_erf_imp(erflowarg));
  }//double gaussian_integral(...)

  // Explicit instantiation definition for the `double` version of `gaussian_integral(...)`
  template void gaussian_integral<double>(const double, const double, const double,
                                  const float * const, double *, const size_t);
  
  
  template void bortel_integral<double>( const double, const double, const double, const double,
                                       const float * const, double *, const size_t );


  
  double crystal_ball_integral( const double mean,
                               const double sigma,
                               const double alpha,
                               const double n,
                               const double x0, const double x1 )
  {
    // TODO: this is just a niave implementation - still needs to be optimized
    
    // Also, the implementation in CERNs ROOT
    //  may better deal with numerical accuracies of tails by switching to integrating in log
    //   see https://root.cern.ch/doc/master/RooCrystalBall_8cxx_source.html
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    
    const double a_0 = (x0 - mean) / sigma;
    const double a_1 = (x1 - mean) / sigma;
    
    if( (a_0 <= -alpha) && (a_1 <= -alpha) )
    {
      // Integrate just among the power law component
      return (crystal_ball_tail_indefinite_t(sigma,alpha,n,a_1)
                               - crystal_ball_tail_indefinite_t(sigma,alpha,n,a_0));
    }
    
    const double A = std::pow(n/alpha, n) * std::exp( -0.5*alpha*alpha );
    //const double B = (n / alpha) - alpha;
    const double C = (n / alpha) * (1.0/(n - 1.0)) * std::exp( -0.5*alpha*alpha );
    const double D = root_half_pi * (1.0 + boost_erf_imp( one_div_root_two * alpha ));
    //const double N = 1.0 / (sigma * (C + D));
    
    const double sqrt_2pi = boost::math::constants::root_two_pi<double>();
    
    const double gauss_amp = sqrt_2pi / (C + D);
    
    if( (a_0 >= -alpha) && (a_1 > -alpha) ) // just the gaussian
      return gauss_amp*gaussian_integral( mean, sigma, x0, x1 );
    
    // integrate power-law from a_0 to -alpha
    // integrate gaussian from -alpha to a_1
    return (crystal_ball_tail_indefinite_t(sigma,alpha,n,-alpha)
                             - crystal_ball_tail_indefinite_t(sigma,alpha,n,a_0))
    + gauss_amp*gaussian_integral( mean, sigma, mean-alpha*sigma, x1 );
  }//crystal_ball_integral(...)

  
  double double_sided_crystal_ball_integral( const double peak_mean,
                                            const double peak_sigma,
                                            const double alpha_low,
                                            const double n_low,
                                            const double alpha_high,
                                            const double n_high,
                                            const double x0, const double x1 )
  {
#ifdef _MSC_VER
#pragma message( "PeakDef::double_sided_crystal_ball_integral not tested/optimized - normalization for power law below 5 starts being off decently" )
#else
#warning "PeakDef::double_sided_crystal_ball_integral not tested/optimized - normalization for power law below 5 starts being off decently"
#endif
    
    const double t0 = (x0 - peak_mean) / peak_sigma;
    const double t1 = (x1 - peak_mean) / peak_sigma;
    
    double answer = 0.0;
    if( t0 < -alpha_low )
      answer += DSCB_left_tail_indefinite_non_norm_t( alpha_low, n_low, std::min(-alpha_low,t1) )
      - DSCB_left_tail_indefinite_non_norm_t( alpha_low, n_low, t0 );
    
    if( t1 > alpha_high )
      answer += DSCB_right_tail_indefinite_non_norm_t( alpha_high, n_high, t1 )
      - DSCB_right_tail_indefinite_non_norm_t( alpha_high, n_high, std::max(alpha_high,t0) );
    
    if( (t0 < alpha_high) && (t1 > -alpha_low) )
      answer += DSCB_gauss_indefinite_non_norm_t( min(alpha_high,t1) )
      - DSCB_gauss_indefinite_non_norm_t( max(-alpha_low,t0) );
    
    const double norm = DSCB_norm( alpha_low, n_low, alpha_high, n_high );
    return norm*answer;
  }//double_sided_crystal_ball_integral(...)

  
  
  // Explicit instantiation definition for the `double` version of `gauss_exp_integral(...)`
  template void gauss_exp_integral<double>( const double, const double, const double,
                                      const double, const float * const, double *, const size_t );
  
  
  // Explicit instantiation definition for the `double` version of `exp_gauss_exp_integral(...)`
  template void exp_gauss_exp_integral<double>( const double, const double, const double,
                                                  const double, const double, const float * const,
                                                  double *, const size_t );
  
  
  // Explicit instantiation definition for the `double` version of `crystal_ball_integral(...)`
  template void crystal_ball_integral<double>( const double, const double, const double,
                        const double, const double, const float * const, double *, const size_t );

  
  // Explicit instantiation definition for the `double` version of `exp_gauss_exp_norm(...)`
  template void double_sided_crystal_ball_integral<double>( const double, const double,
                                                             const double, const double, const double,
                                                             const double, const double, const float * const,
                                                             double *, const size_t );
}//namespace PeakDists
