/* InterSpec: an application to analyze spectral gamma radiation data.
 
 Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
 (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
 Government retains certain rights in this software.
 For questions contact William Johnson via email at wcjohns@sandia.gov, or
 alternative emails of interspec@sandia.gov.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include "InterSpec_config.h"

#include <memory>
#include <iostream>

#include <boost/math/constants/constants.hpp>
#include <boost/math/special_functions/erf.hpp>
#include <boost/math/distributions/poisson.hpp>

#include "InterSpec/PeakDef.h"
#include "InterSpec/PeakDists.h"

using namespace std;


namespace PeakDists
{
  /** 20191230: wcjohns extracted the boost::math::erf() function implementation
   from boost 1.65.1 for double precision (53 bit mantissa) into this function,
   boost_erf_imp(). Removing some of the supporting code structure, and
   explicitly writing out the polynomial equation evaluation seems to speed
   things up by about a factor of ~3 over calling boost::math::erf().
   
   Using the commented out erf_approx() function looks to be about 25% faster than
   this boost version, but I havent carefully checked out the precision implications
   so not switching to it yet.
   
   Surprisingly, the erf() function is the major bottleneck for peak fitting.
   */
  double boost_erf_imp( double z )
  {
    /* Since this function is a (slight) modification of boost source code, it
     is subject to the Boost Version 1 Software License, whose text is:
     
     Boost Software License - Version 1.0 - August 17th, 2003
     
     Permission is hereby granted, free of charge, to any person or organization
     obtaining a copy of the software and accompanying documentation covered by
     this license (the "Software") to use, reproduce, display, distribute,
     execute, and transmit the Software, and to prepare derivative works of the
     Software, and to permit third-parties to whom the Software is furnished to
     do so, all subject to the following:
     
     The copyright notices in the Software and this entire statement, including
     the above license grant, this restriction and the following disclaimer,
     must be included in all copies of the Software, in whole or in part, and
     all derivative works of the Software, unless such copies or derivative
     works are solely in the form of machine-executable object code generated by
     a source language processor.
     
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
     SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
     FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
     ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     DEALINGS IN THE SOFTWARE.
     */
    if(z < 0)
      return -boost_erf_imp( -z );
    
    if( z < 0.5 )
    {
      if( z < 1e-10 )
      {
        return z * 1.125f + z * 0.003379167095512573896158903121545171688;
      }else
      {
        const double zz = z * z;
        const double P_eval = (((zz*-0.000322780120964605683831 + -0.00772758345802133288487)*zz + -0.0509990735146777432841)*zz + -0.338165134459360935041)*zz + 0.0834305892146531832907;
        const double Q_eval = (((zz*0.000370900071787748000569 + 0.00858571925074406212772)*zz + 0.0875222600142252549554)*zz + 0.455004033050794024546)*zz + 1.0;
        
        return z * (1.044948577880859375f + P_eval / Q_eval);
      }
    }else if( z < 5.8f )
    {
      if(z < 1.5f)
      {
        static const double Y = 0.405935764312744140625f;
        static const double P[] = { -0.098090592216281240205, 0.178114665841120341155,
          0.191003695796775433986, 0.0888900368967884466578, 0.0195049001251218801359,
          0.00180424538297014223957
        };
        static const double Q[] = { 1.0, 1.84759070983002217845,
          1.42628004845511324508, 0.578052804889902404909, 0.12385097467900864233,
          0.0113385233577001411017, 0.337511472483094676155e-5
        };
        
        const double zarg = z - 0.5;
        const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
        const double Q_eval = (((((Q[6]*zarg + Q[5])*zarg + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
        
        return 1 - (Y + P_eval / Q_eval) * (exp(-z * z) / z);
      }else if(z < 2.5f)
      {
        static const double Y = 0.50672817230224609375f;
        static const double P[] = { -0.0243500476207698441272, 0.0386540375035707201728,
          0.04394818964209516296, 0.0175679436311802092299, 0.00323962406290842133584,
          0.000235839115596880717416
        };
        static const double Q[] = { 1.0, 1.53991494948552447182, 0.982403709157920235114,
          0.325732924782444448493, 0.0563921837420478160373, 0.00410369723978904575884
        };
        
        const double zarg = z - 1.5;
        const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
        const double Q_eval = ((((zarg*Q[5] + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
        
        return 1 - (Y + P_eval / Q_eval) * (exp(-z * z) / z);
      }
      else if(z < 4.5f)
      {
        static const double Y = 0.5405750274658203125f;
        static const double P[] = { 0.00295276716530971662634, 0.0137384425896355332126,
          0.00840807615555585383007, 0.00212825620914618649141, 0.000250269961544794627958,
          0.113212406648847561139e-4
        };
        static const double Q[] = { 1.0, 1.04217814166938418171,
          0.442597659481563127003, 0.0958492726301061423444, 0.0105982906484876531489,
          0.000479411269521714493907
        };
        
        const double zarg = z - 3.5;
        const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
        const double Q_eval = ((((zarg*Q[5] + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
        
        return 1 - (Y + P_eval / Q_eval) * (exp(-z * z) / z);
      }else
      {
        static const double Y = 0.5579090118408203125f;
        static const double P[] = { 0.00628057170626964891937, 0.0175389834052493308818,
          -0.212652252872804219852, -0.687717681153649930619, -2.5518551727311523996,
          -3.22729451764143718517, -2.8175401114513378771
        };
        static const double Q[] = { 1.0, 2.79257750980575282228, 11.0567237927800161565,
          15.930646027911794143, 22.9367376522880577224, 13.5064170191802889145,
          5.48409182238641741584
        };
        
        const double zarg = 1.0 / z;
        const double P_eval = (((((P[6]*zarg + P[5])*zarg + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
        const double Q_eval = (((((Q[6]*zarg + Q[5])*zarg + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
        
        return 1 - (Y + P_eval / Q_eval) * (exp(-z * z) / z);
      }
    }
    
    return 1;
  }//double boost_erf_imp( double z )
  
  
  /** 20231123: The JavaScript needed a better `erfc` implementation than just `1-erf`, or otherwise there were huge
   artifacts, and regions that just wouldnt draw, so wcjohns extracted this `erfc` function from boost; boost implements `erf`
   and `erfc` in the same function, but since the JS just needs `erfc`, wcjohns separated the erf and erf implementation, even
   though they are largely duplicate - saves some small amount of code/overhead.
   */
  double boost_erfc_imp( double z )
  {
    /* Since this function is a (slight) modification of boost source code, it
     is subject to the Boost Version 1 Software License, whose text is:
     
     Boost Software License - Version 1.0 - August 17th, 2003
     
     Permission is hereby granted, free of charge, to any person or organization
     obtaining a copy of the software and accompanying documentation covered by
     this license (the "Software") to use, reproduce, display, distribute,
     execute, and transmit the Software, and to prepare derivative works of the
     Software, and to permit third-parties to whom the Software is furnished to
     do so, all subject to the following:
     
     The copyright notices in the Software and this entire statement, including
     the above license grant, this restriction and the following disclaimer,
     must be included in all copies of the Software, in whole or in part, and
     all derivative works of the Software, unless such copies or derivative
     works are solely in the form of machine-executable object code generated by
     a source language processor.
     
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
     SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
     FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
     ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     DEALINGS IN THE SOFTWARE.
     */

    if( z < 0 )
      return (z < -0.5) ? (2 - boost_erfc_imp( -z )) : (1 + boost_erf_imp( -z ));
    
    if( z < 0.5 )
      return 1 - boost_erf_imp( z );
    
    if( z >= 28 )
      return 0;
    
    if(z < 1.5f)
    {
      static const double P[] = { -0.098090592216281240205, 0.178114665841120341155,
        0.191003695796775433986, 0.0888900368967884466578, 0.0195049001251218801359,
        0.00180424538297014223957
      };
      static const double Q[] = { 1.0, 1.84759070983002217845,
        1.42628004845511324508, 0.578052804889902404909, 0.12385097467900864233,
        0.0113385233577001411017, 0.337511472483094676155e-5
      };
      
      const double zarg = z - 0.5;
      const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
      const double Q_eval = (((((Q[6]*zarg + Q[5])*zarg + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
      
      return (0.405935764312744140625f + P_eval / Q_eval) * (exp(-z * z) / z);
    }//if(z < 1.5f)
    
    if( z < 2.5f )
    {
      static const double P[] = { -0.0243500476207698441272, 0.0386540375035707201728,
        0.04394818964209516296, 0.0175679436311802092299, 0.00323962406290842133584,
        0.000235839115596880717416
      };
      static const double Q[] = { 1.0, 1.53991494948552447182, 0.982403709157920235114,
        0.325732924782444448493, 0.0563921837420478160373, 0.00410369723978904575884
      };
      
      const double zarg = z - 1.5;
      const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
      const double Q_eval = ((((zarg*Q[5] + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
      
      return (0.50672817230224609375f + P_eval / Q_eval) * (exp(-z * z) / z);
      // Boost implementation has an additional minor error correction here
    }//if( z < 2.5f
    
    if( z < 4.5f )
    {
      static const double P[] = { 0.00295276716530971662634, 0.0137384425896355332126,
        0.00840807615555585383007, 0.00212825620914618649141, 0.000250269961544794627958,
        0.113212406648847561139e-4
      };
      static const double Q[] = { 1.0, 1.04217814166938418171,
        0.442597659481563127003, 0.0958492726301061423444, 0.0105982906484876531489,
        0.000479411269521714493907
      };
      
      const double zarg = z - 3.5;
      const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
      const double Q_eval = ((((zarg*Q[5] + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
      return (0.5405750274658203125f + P_eval / Q_eval) * (exp(-z * z) / z);
      // Boost implementation has an additional minor error correction here
    }//if( z < 4.5f )
    
    static const double P[] = { 0.00628057170626964891937, 0.0175389834052493308818,
      -0.212652252872804219852, -0.687717681153649930619, -2.5518551727311523996,
      -3.22729451764143718517, -2.8175401114513378771
    };
    static const double Q[] = { 1.0, 2.79257750980575282228, 11.0567237927800161565,
      15.930646027911794143, 22.9367376522880577224, 13.5064170191802889145,
      5.48409182238641741584
    };
    
    const double zarg = 1.0 / z;
    const double P_eval = (((((P[6]*zarg + P[5])*zarg + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
    const double Q_eval = (((((Q[6]*zarg + Q[5])*zarg + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
    
    return (0.5579090118408203125f + P_eval / Q_eval) * (exp(-z * z) / z);
    // Boost implementation has an additional minor error correction here
}//double boost_erfc_imp( double z )
  
  /*
  double erf_approx( double x )
  {
    //https://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python#answer-457805
    // Error is less than 1.5 * 10-7 for all inputs
    // (originally from Handbook of Mathematical Functions)
    const double sign = (x >= 0) ? 1 : -1;
    x = fabs(x);
    const double t = 1.0/(1.0 + 0.3275911*x);
    const double y = 1.0 - (((((1.061405429 * t + -1.453152027) * t) + 1.421413741) * t + -0.284496736) * t + 0.254829592) * t * std::exp(-x * x);
    return sign * y;
  }
   */
  

  void photopeak_function_integral( const double mean,
                                          const double sigma,
                                          const double amp,
                                          const PeakDef::SkewType skew_type,
                                          const double * const skew_parameters,
                                          const size_t nchannel,
                                          const float * const energies,
                                          double *channels )
  {
    assert( (skew_type == PeakDef::SkewType::NoSkew) || skew_parameters );
    
    switch( skew_type )
    {
      case PeakDef::SkewType::NoSkew:
        gaussian_integral( mean, sigma, amp, energies, channels, nchannel );
        break;
        
      case PeakDef::SkewType::Bortel:
        bortel_integral( mean, sigma, amp, skew_parameters[0], energies, channels, nchannel );
        break;
        
      case PeakDef::SkewType::CrystalBall:
        crystal_ball_integral( mean, sigma, amp, skew_parameters[0], skew_parameters[1], energies, channels, nchannel );
        break;
        
      case PeakDef::SkewType::DoubleSidedCrystalBall:
        double_sided_crystal_ball_integral( mean, sigma, amp,
                                           skew_parameters[0], skew_parameters[1],
                                           skew_parameters[2], skew_parameters[3],
                                           energies, channels, nchannel );
        break;
        
      case PeakDef::SkewType::GaussExp:
        gauss_exp_integral( mean, sigma, amp, skew_parameters[0], energies, channels, nchannel );
        break;
        
      case PeakDef::SkewType::ExpGaussExp:
        exp_gauss_exp_integral( mean, sigma, amp, skew_parameters[0], skew_parameters[1], energies, channels, nchannel );
        break;
    }//switch( skew_type )
  }//void photopeak_function_integral(...)
  
  /** Returns the PDF for a unit-area Bortel function.
   */
  double bortel_pdf( const double mean, const double sigma, const double skew_low, const double x )
  {
    // 32-bit floats have a normalized range of 1E-38 to 1E38; 64bit floats 1E-308 to 1E308
    // We could use the proper functions up to ~1E308, but to be conservative, but to be
    // a little conservative, we'll switch to using a gaussian when the exp() and erfc()
    // functions start returning values with limits near 1E-38 or 1E38.
    // Although difference between the methods will start out ar ~30% and increase to >100%,
    // the function values are so small, they dont really matter.
    // TODO: try expanding the function, around (or above) `mean` to see if there can be a better approximation
    
    const double exp_arg = ((x - mean)/skew_low) + (sigma*sigma/(2*skew_low*skew_low));
    const double erfc_arg = 0.7071067812*(((x - mean)/sigma) + (sigma/skew_low));
    
    if( (skew_low <= 0.0) || (exp_arg > 87.0) || (erfc_arg > 10.0) )
    {
      const double a = (x-mean)/sigma;
      return (1.0/(sigma*2.5066282746)) * std::exp( -0.5 * a*a );
    }
    
    return (0.5/skew_low)*std::exp( exp_arg ) * boost_erfc_imp( erfc_arg );
  }//double bortel_pdf(...)


  /** Returns the indefinite integral (e.g., from negative infinity up to `x`) of a unit-area Bortel function
   */
  double bortel_indefinite_integral( const double x, const double mean,
                           const double sigma, const double skew )
  {
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>();
   
    const double t = (x - mean) / sigma;
    const double erf_arg = one_div_root_two*t;
    const double exp_arg = sigma*(2*skew*t + sigma) / (2*skew*skew);
    const double erfc_arg = one_div_root_two*(t + (sigma/skew));
    
    if( (skew <= 0.0) || (exp_arg > 87.0) || (erfc_arg > 10.0) )
      return 0.5 * boost_erf_imp(erf_arg);
    
    return 0.5*(boost_erf_imp(erf_arg) + (std::exp(exp_arg) * boost_erfc_imp(erfc_arg)));
  }//double bortel_indefinite

  
  double bortel_integral( const double mean, const double sigma, const double skew,
                         const double x1, const double x2 )
  {
    return bortel_indefinite_integral(x2, mean, sigma, skew )
      - bortel_indefinite_integral(x1, mean, sigma, skew );
  }

  /** Returns an approximate area between `x1` and `x2` for a unit-area Bortel function.
   
   Just multiplies the x-range by the Bortel PDF value in the middle of the range.
   */
  double bortel_integral_fast( const double mean, const double sigma, const double skew,
                              const double x1, const double x2 )
  {
    const double half_way_x = 0.5*(x1 + x2);
    return (x2 - x1) * bortel_pdf( mean, sigma, skew, half_way_x );
  }
  
  
  std::pair<double,double> bortel_coverage_limits( const double mean, const double sigma,
                                         const double skew, const double p )
  {
    if( (p <= 1.0E-11) || (p > 0.999)  ) // 7 sigma would be 1.279812544E-12, so to account for skew
      throw runtime_error( "bortel_coverage_limits: invalid p" );
    
    try
    {
      auto tail_cdf = [mean,sigma,skew,p]( const double x ) -> double {
        const double cdf = bortel_indefinite_integral( x, mean, sigma, skew );
        const double answer = -0.5*p + (cdf + 0.5);
        return answer;
      };
      
      auto term_condition = [p]( const double left, const double right ) -> bool {
        return fabs(left - right) < 0.01*p;
      };
      
      boost::uintmax_t max_iter = 100;
      const double low_low_limit = mean - 50*sigma;  //50 sigma is arbitrary
      const double low_up_limit = mean - skew*sigma;
      const pair<double,double> lower_val = boost::math::tools::bisect( tail_cdf, low_low_limit,
                                                          low_up_limit, term_condition, max_iter );
      const double lower_x = 0.5*(lower_val.first + lower_val.second);
      
      
      auto upper_cdf = [mean,sigma,skew,p]( const double x ) -> double {
        const double cdf = bortel_indefinite_integral( x, mean, sigma, skew );
        return 0.5*p + (-0.5 + cdf);
      };
       
      max_iter = 100;
      const double up_low_limit = mean;
      const double up_up_limit = mean + 7*sigma;
      const pair<double,double> upper_val = boost::math::tools::bisect( upper_cdf, up_low_limit,
                                                          up_up_limit, term_condition, max_iter );
      const double upper_x = 0.5*(upper_val.first + upper_val.second);
        
      assert( (1.0 - bortel_integral(mean, sigma, skew, lower_val.first, upper_val.second)) <= (p + 1.0E-6) );
      assert( (1.0 - bortel_integral(mean, sigma, skew, lower_val.second, upper_val.first)) >= (p - 1.0E-6) );
      
      return pair<double,double>( lower_x, upper_x );
    }catch( std::exception &e )
    {
      throw runtime_error( "bortel_coverage_limits: failed to find limit: " + string(e.what()) );
    }//try / catch
    
    assert( 0 );
    return std::pair<double,double>( -1.0, -1.0 );
  }//bortel_coverage_limits(...)
  
  
  std::pair<double,double> gauss_exp_coverage_limits( const double mean, const double sigma,
                                         const double skew, const double p )
  {
    const double root_two = boost::math::constants::root_two<double>();
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    
    const double norm = gauss_exp_norm(sigma,skew);
    const double tail_norm = norm * (sigma / skew);
    
    const double indefinite_of_tail = tail_norm * std::exp( -0.5*skew*skew );
    const double erf_neg_skew = boost_erf_imp(-skew*one_div_root_two);
    const double gaus_norm = norm * sigma * root_half_pi;
    
    if( (p <= 1.0E-11) || (p > 0.999)  ) // for gaussian, 7 sigma would be 1.279812544E-12
      throw runtime_error( "gauss_exp_coverage_limits: invalid p" );
    
    try
    {
      auto x_from_eqn = [mean, sigma, skew, tail_norm, indefinite_of_tail, root_two, erf_neg_skew, gaus_norm]( const double prob ) -> double {
        if( prob <= indefinite_of_tail )
        {
          const double t_eqn = (1/skew)*log(prob/tail_norm) - 0.5*skew;
          return t_eqn*sigma + mean;
        }
        
        // TODO: check that boost::math::erf_inv(double) doesnt iterate to find a precise enough
        //       solution, but if it does, maybe try using boost::math::policies::policy<boost::math::policies::digits10<8> >
        const double t_eqn = root_two * boost::math::erf_inv( erf_neg_skew + (prob - indefinite_of_tail)/gaus_norm );
        return t_eqn*sigma + mean;
      };//auto x_from_eqn
      
      const double lower_x = x_from_eqn( 0.5*p );
      const double upper_x = x_from_eqn( 1.0 - 0.5*p );
        
      if( IsNan(lower_x) || IsInf(lower_x) || IsNan(upper_x) || IsInf(upper_x) )
        throw runtime_error( "got invalid answer" );
      
      assert( (1.0 - gauss_exp_integral( mean, sigma, skew, lower_x, upper_x)) <= (p + 1.0E-6) );
        
      return pair<double,double>( lower_x, upper_x );
    }catch( std::exception &e )
    {
      throw runtime_error( "gauss_exp_coverage_limits: failed to find limit: " + string(e.what()) );
    }//try / catch
    
    assert( 0 );
    return std::pair<double,double>( -1.0, -1.0 );
  }//gauss_exp_coverage_limits(...)
  
  
  std::pair<double,double> exp_gauss_exp_coverage_limits( const double mean, const double sigma,
                                const double left_skew, const double right_skew, const double p )
  {
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    const double root_half_pi = boost::math::constants::root_half_pi<double>(); //1.2533141373155002512078826424
    
    const double norm = exp_gauss_exp_norm( sigma, left_skew, right_skew );
    const double left_tail_norm = norm*(sigma/left_skew);
    const double right_tail_norm = norm*(sigma / right_skew);
    const double rtail_constant = std::exp(-right_skew*right_skew/2);
    const double gaus_constant = norm * sigma * root_half_pi;
    const double erf_left_skew = boost_erf_imp( -one_div_root_two*left_skew );
    
    const double indef_at_left_skew = left_tail_norm*std::exp( -0.5*left_skew*left_skew );
    const double indef_at_right_skew = indef_at_left_skew + gaus_constant * (boost_erf_imp( one_div_root_two*right_skew ) - erf_left_skew );
    
    
    if( (p <= 1.0E-11) || (p > 0.999)  ) // for gaussian, 7 sigma would be 1.279812544E-12
      throw runtime_error( "exp_gauss_exp_coverage_limits: invalid p" );
    
    try
    {
      auto x_from_eqn = [indef_at_right_skew,indef_at_left_skew,left_skew,left_tail_norm,mean,sigma,
                         one_div_root_two,erf_left_skew,gaus_constant,right_skew,right_tail_norm,rtail_constant]( const double prob ) -> double {
        if( prob <= indef_at_left_skew )
        {
          const double t_eqn = -0.5*left_skew  + log(prob/left_tail_norm)/left_skew;
          return t_eqn*sigma + mean;
        }
        
        if( prob < indef_at_right_skew )
        {
          const double t_eqn = boost::math::erf_inv( (prob - indef_at_left_skew + gaus_constant*erf_left_skew)/gaus_constant )/one_div_root_two;
          return t_eqn*sigma + mean;
        }
        
        const double t_eqn = 0.5*right_skew - log(rtail_constant - (prob - indef_at_right_skew)/right_tail_norm)*(1/right_skew);
        return t_eqn*sigma + mean;
      };//auto x_from_eqn
      
      
      const double lower_x = x_from_eqn( 0.5*p );
      const double upper_x = x_from_eqn( 1.0 - 0.5*p );
      
      if( IsNan(lower_x) || IsInf(lower_x) || IsNan(upper_x) || IsInf(upper_x) )
        throw runtime_error( "got invalid answer" );
      
      assert( (1.0 - exp_gauss_exp_integral( mean, sigma, left_skew, right_skew, lower_x, upper_x)) <= (p + 1.0E-6) );
      
      return pair<double,double>( lower_x, upper_x );
    }catch( std::exception &e )
    {
      throw runtime_error( "exp_gauss_exp_coverage_limits: failed to find limit: " + string(e.what()) );
    }//try / catch
    
    assert( 0 );
    return std::pair<double,double>( -1.0, -1.0 );
  }//exp_gauss_exp_coverage_limits(...)
  
  
  
  std::pair<double,double> crystal_ball_coverage_limits( const double mean, const double sigma,
                                                        const double alpha,
                                                        const double n,
                                                        const double p )
  {
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    const double sqrt_2pi = boost::math::constants::root_two_pi<double>();
    
    const double A = std::pow(n/alpha, n) * std::exp( -0.5*alpha*alpha );
    const double B = (n / alpha) - alpha;
    const double C = (n / alpha) * (1.0/(n - 1.0)) * std::exp( -0.5*alpha*alpha );
    const double D = root_half_pi * (1.0 + boost_erf_imp( one_div_root_two * alpha ));
    const double N = 1.0 / (sigma * (C + D));
    const double tail_norm = N * A * sigma / (n - 1.0);
    const double gauss_indef_amp = 0.5 * sqrt_2pi / (C + D);
    const double gaus_indef_at_skew = gauss_indef_amp * boost_erf_imp( -alpha*one_div_root_two );
    const double indefinite_of_tail = tail_norm * std::pow( B + alpha, 1.0 - n );
    
    if( (p <= 1.0E-11) || (p > 0.999)  ) // for gaussian, 7 sigma would be 1.279812544E-12
      throw runtime_error( "crystal_ball_coverage_limits: invalid p" );
    
    try
    {
      auto x_from_eqn = [tail_norm,indefinite_of_tail,B,n,one_div_root_two,sigma,mean,
                         gauss_indef_amp,gaus_indef_at_skew]( const double prob ) -> double {
        if( prob < indefinite_of_tail )
        {
          const double t_eqn = B - std::pow( prob/tail_norm, 1.0/(1.0 - n));
          return t_eqn*sigma + mean;
        }
        
        const double root_two = boost::math::constants::root_two<double>(); //1.414213562373095048801688724209698078
        const double t_eqn = root_two* boost::math::erf_inv( (1.0/gauss_indef_amp) * (prob - indefinite_of_tail + gaus_indef_at_skew) );
        return t_eqn*sigma + mean;
      };//auto x_from_eqn
      
      const double lower_x = x_from_eqn( 0.5*p );
      const double upper_x = x_from_eqn( 1.0 - 0.5*p );
      
      if( IsNan(lower_x) || IsInf(lower_x) || IsNan(upper_x) || IsInf(upper_x) )
        throw runtime_error( "got invalid answer" );
      
      assert( (1.0 - crystal_ball_integral(mean, sigma, alpha, n, lower_x, upper_x)) <= (p + 1.0E-6) );
      
      return pair<double,double>( lower_x, upper_x );
    }catch( std::exception &e )
    {
      throw runtime_error( "crystal_ball_coverage_limits: failed to find limit: " + string(e.what()) );
    }//try / catch
    
    assert( 0 );
    return std::pair<double,double>( -1.0, -1.0 );
  }//crystal_ball_coverage_limits(...)
  
  
  std::pair<double,double> double_sided_crystal_ball_coverage_limits( const double mean, const double sigma,
                                                                     const double left_skew,
                                                                     const double left_n,
                                                                     const double right_skew,
                                                                     const double right_n,
                                                                     const double p )
  {
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    const double root_half_pi = boost::math::constants::root_half_pi<double>(); //1.2533141373155002512078826424
    
    const double norm = DSCB_norm( left_skew, left_n, right_skew, right_n );
    const double exp_lower_aa = std::exp(-0.5*left_skew*left_skew);
    const double exp_upper_aa = std::exp(-0.5*right_skew*right_skew);
    const double right_tail_indef_at_rskew = norm * exp_upper_aa*(1.0 / ((right_skew / right_n) - right_skew));
    
    auto left_tail_indefinite_t = [left_skew, left_n, norm, exp_lower_aa]( const double t ) -> double {
      const double t_1 = (t == -left_skew) ? 1.0 : 1.0 - (left_skew / (left_n / (left_skew + t)));
      return -norm * exp_lower_aa * (t_1 / std::pow(t_1, left_n)) / ((left_skew / left_n) - left_skew); //slightly more stable
    };
    
    
    auto right_tail_indefinite_t = [right_skew, right_n, norm, exp_upper_aa, right_tail_indef_at_rskew]( const double t ) -> double {
      const double t_1 = (t == right_skew) ? 1.0 : (1.0 + ((right_skew * (t - right_skew)) / right_n));
      return norm * exp_upper_aa*(1.0 / ((right_skew / right_n) - right_skew)) * std::pow(t_1, (1.0 - right_n)) - right_tail_indef_at_rskew;
    };
    
    assert( right_tail_indefinite_t(right_skew) == 0 );
    
    const double gaus_indef_at_left_skew = norm * root_half_pi * boost_erf_imp( -left_skew * one_div_root_two );
    auto gauss_indefinite_t = [norm, gaus_indef_at_left_skew, one_div_root_two, root_half_pi]( const double t ) -> double {
      return norm * root_half_pi * boost_erf_imp( one_div_root_two * t ) - gaus_indef_at_left_skew;
    };
    
    const double indef_at_left_skew = left_tail_indefinite_t( -left_skew );
    const double indef_at_right_skew = indef_at_left_skew + gauss_indefinite_t( right_skew );
    
    auto indefinite_x = [mean, sigma, left_skew, right_skew,
                       left_tail_indefinite_t, right_tail_indefinite_t, gauss_indefinite_t,
                       indef_at_left_skew, indef_at_right_skew]( const double x ) {
      const double t = (x - mean) / sigma;
      if( t <= -left_skew )
        return left_tail_indefinite_t( t );
      
      if( t <= right_skew )
        return indef_at_left_skew + gauss_indefinite_t( t );
      
      return indef_at_right_skew + right_tail_indefinite_t( t );
    };
    
    
    auto lower_fcn = [mean, sigma, left_skew, right_skew, p, indefinite_x]( const double x ) -> double {
      return -0.5*p + indefinite_x( x );
    };
    
    auto upper_fcn = [mean, sigma, left_skew, right_skew, p, indefinite_x]( const double x ) -> double {
      return -0.5*p + (1.0 - indefinite_x( x ));
    };
    
    if( (p <= 1.0E-11) || (p > (1.0 - 1.0E-11))  ) // for gaussian, 7 sigma would be 1.279812544E-12
      throw runtime_error( "double_sided_crystal_ball_coverage_limits: invalid p" );
    
    auto x_from_eqn = [mean, sigma, norm, left_skew, left_n, right_skew, right_n,
                       indef_at_left_skew, indef_at_right_skew, gaus_indef_at_left_skew,
                       right_tail_indef_at_rskew, exp_lower_aa, exp_upper_aa, root_half_pi ]( const double prob ) -> double {
      if( prob <= indef_at_left_skew )
      {
        // TODO: these next lines could probably be way simplified and improved
        const double tmp = std::pow( -prob * ((left_skew / left_n) - left_skew) / (norm * exp_lower_aa), 1.0/(1-left_n));
        const double t_eqn = -left_skew + left_n*((1.0 - tmp)/left_skew);
        return t_eqn*sigma + mean;
      }
      
      if( prob < indef_at_right_skew )
      {
        const double root_two = boost::math::constants::root_two<double>();
        const double t_eqn = root_two * boost::math::erf_inv( (prob - indef_at_left_skew + gaus_indef_at_left_skew) / (norm * root_half_pi) );
        return t_eqn*sigma + mean;
      }
  
      // TODO: Fix these not working
      const double pow_arg = right_tail_indef_at_rskew + ((right_skew / right_n) - right_skew)*(prob - indef_at_right_skew)/(norm * exp_upper_aa);
      const double tmp = std::pow( pow_arg, 1.0/(1.0-right_n) );
      const double t_eqn = right_skew + (right_n/right_skew) *(tmp - 1.0);
      
      // TODO: for some reason inverting the right tail doesnt work (`pow_arg` is negative); math must be wrong
      throw runtime_error( "Inverting right tail doesnt work yet" );
      
      return t_eqn*sigma + mean;
    };//auto x_from_eqn
    
    
    try
    {
      auto term_condition = [p]( const double left, const double right ) -> bool {
        return fabs(left - right) < 0.01*p;
      };

      // TODO: if value is in right tail, we will fail, in which case we will resort to an iterative solution
      double lower_x = -999, upper_x = -999;
      try
      {
        lower_x = x_from_eqn( 0.5*p );
      }catch( std::exception & )
      {
        cout << "Failed to find lower answer by eqn from p=" << p << endl;
      }
      
      try
      {
        upper_x = x_from_eqn( 1.0 - 0.5*p );
      }catch( std::exception & )
      {
        cout << "Failed to find upper answer by eqn from p=" << p << endl;
      }
      

      if( (lower_x < -998) || IsNan(lower_x) || IsInf(lower_x) )
      {
        // With huge skew and/or small probabilities, the energy-value we are looking for can be
        //  really far away from mean, so we will search by doubling the search range.
        double low_low_limit;
        bool found_lower = false;
        const size_t max_range_doublings = 40;
        double current_dx = 20.0 * std::max(sigma, 0.1); //20 sigma starting is arbitrary
        for( size_t i = 0; !found_lower && (i < max_range_doublings); ++i, current_dx *= 2 )
        {
          low_low_limit = mean - current_dx;
          const double y = lower_fcn( low_low_limit );
          found_lower = (y < 0.0);
        }//for( look for x where pdf has gone below limit )
        
        // If we didnt find the lower limit, `boost::math::tools::bisect(...)` will throw exception
        //assert( found_lower );
        
#if( PERFORM_DEVELOPER_CHECKS )
        if( !found_lower )
        {
          const string msg = "Failed to find lower limit by " + std::to_string(mean - current_dx)
          + " for double_sided_crystal_ball_coverage_limits( "
          + std::to_string(mean) + ", " + std::to_string(sigma) + ", " + std::to_string(left_skew)
          + ", " + std::to_string(left_n) + ", " + std::to_string(right_skew) + ", "
          + std::to_string(right_n) + ", " + std::to_string(p) + " )";
          
          log_developer_error( __func__, msg.c_str() );
        }//if( !found_upper )
#endif
        
        boost::uintmax_t max_iter = 1000;
        const pair<double,double> lower_val = boost::math::tools::bisect( lower_fcn, low_low_limit,
                                                                         mean, term_condition, max_iter );
        lower_x = 0.5*(lower_val.first + lower_val.second);
      }//if( lower_x < 989 || IsNan(lower_x) || IsInf(lower_x) )
      
       
      if( (upper_x < -998) || IsNan(upper_x) || IsInf(upper_x) )
      {
        // With huge skew and/or small probabilities, the energy-value we are looking for can be
        //  really huge, so we will search by doubling the search range.
        double up_up_limit;
        bool found_upper = false;
        const size_t max_range_doublings = 40;
        double current_dx = 20.0 * std::max(sigma, 0.1);
        for( size_t i = 0; !found_upper && (i < max_range_doublings); ++i, current_dx *= 2 )
        {
          up_up_limit = mean + current_dx;
          const double y = upper_fcn( up_up_limit );
          found_upper = (y < 0.0);
        }//for( look for x where pdf has gone below limit )
        
        // If we didnt find the upper limit, `boost::math::tools::bisect(...)` will throw exception
        //assert( found_upper );
        
#if( PERFORM_DEVELOPER_CHECKS )
        if( !found_upper )
        {
          const string msg = "Failed to find upper limit by " + std::to_string(mean + current_dx)
          + " for double_sided_crystal_ball_coverage_limits( "
          + std::to_string(mean) + ", " + std::to_string(sigma) + ", " + std::to_string(left_skew)
          + ", " + std::to_string(left_n) + ", " + std::to_string(right_skew) + ", "
          + std::to_string(right_n) + ", " + std::to_string(p) + " )";
          
          log_developer_error( __func__, msg.c_str() );
        }//if( !found_upper )
#endif

        boost::uintmax_t max_iter = 1000;
        const pair<double,double> upper_val = boost::math::tools::bisect( upper_fcn, mean,
                                                                         up_up_limit, term_condition, max_iter );
        upper_x = 0.5*(upper_val.first + upper_val.second);
      }//if( upper_x < 989 || IsNan(upper_x) || IsInf(upper_x) )
        
      
      if( IsNan(lower_x) || IsInf(lower_x) || IsNan(upper_x) || IsInf(upper_x) )
        throw runtime_error( "got inf or NaN value" );
      
      
      return pair<double,double>( lower_x, upper_x );
    }catch( std::exception &e )
    {
      const string excmsg = e.what();
      throw runtime_error( "double_sided_crystal_ball_coverage_limits: failed to find limit: " + excmsg );
    }//try / catch
    
    assert( 0 );
    return std::pair<double,double>( -1.0, -1.0 );
  }//double_sided_crystal_ball_coverage_limits(...)
  
  
  double crystal_ball_norm( const double sigma,
                           const double alpha,
                           const double n )
  {
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>();
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    
    const double C = (n / alpha) * (1.0/(n - 1.0)) * std::exp( -0.5*alpha*alpha );
    const double D = root_half_pi * (1.0 + boost_erf_imp( one_div_root_two * alpha ));
    const double N = 1.0 / (sigma * (C + D));
    
    return N;
  }
  
  double crystal_ball_pdf(const double mean,
                          const double sigma,
                          const double alpha,
                          const double n,
                          const double x )
  {
    // From https://en.wikipedia.org/wiki/Crystal_Ball_function
    assert( alpha > 0.0 );
    if( alpha <= 0.0 )
      throw runtime_error( "crystal_ball_pdf: alpha must be >0" );
    
    assert( n > 1.0 );
    if( n <= 1.0 )
      throw runtime_error( "crystal_ball_pdf: power-law must be >1" );
    
    const double N = crystal_ball_norm( sigma, alpha, n );
    const double t = (x - mean) / sigma;
    
    if( t <= -alpha )
    {
      const double A = std::pow( n/alpha, n) * std::exp( -0.5*alpha*alpha );
      const double B = (n / alpha) - alpha;
      return N*A*std::pow( B - t, -n );
    }
    
    return N * std::exp( -0.5*t*t );
  }//crystal_ball_pdf


  /** Returns indefinite integral (negative infinite to `x0` for the power-law component for the unit-area Crystal Ball function.
   */
  double crystal_ball_tail_indefinite_t( const double sigma,
                                          const double alpha,
                                          const double n,
                                          const double t )
  {
    // TODO: this is just a niave implementation - still needs to be optimized
    // The CERN ROOT implementation switches to a log-version of this integral when `n` is
    //  less than 1 + 1E-5 - which makes sense, but for the moment lets just avoid n approaching 1
    assert( t <= -alpha );
    assert( alpha > 0.0 );
    assert( n > 1.0 );
    
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.7071....
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    
    const double A = std::pow(n/alpha, n) * std::exp( -0.5*alpha*alpha );
    const double B = (n / alpha) - alpha;
    const double C = (n / alpha) * (1.0/(n - 1.0)) * std::exp( -0.5*alpha*alpha );
    const double D = root_half_pi * (1.0 + boost_erf_imp( one_div_root_two * alpha ));
    const double N = 1.0 / (sigma * (C + D));
    
    return N * A * sigma * std::pow( B - t, 1.0 - n ) / (n - 1.0);
  }//crystal_ball_tail_indefinite_t

  /*
  double DSCB_pdf_non_norm( const double mean, const double sigma,
                            const double alpha_low, const double n_low,
                            const double alpha_high, const double n_high,
                            const double x )
  {
    // From chapter 6 of https://arxiv.org/pdf/1606.03833.pdf
    double t = (x - mean) / sigma;
    
    if( (t >= -alpha_low) && (t <= alpha_high) ) //Return gaussian value
      return std::exp(-0.5*t*t);
    
    // Return tail value
    const double n = (t > 0.0) ? n_high : n_low;
    const double alpha = (t > 0.0) ? alpha_high : alpha_low;
    t = (t > 0.0) ? -t : t;
    
    //return std::exp(-0.5*alpha*alpha) * std::pow( (alpha/n)*((n/alpha) - alpha - t), -n );
    return std::exp(-0.5*alpha*alpha) * std::pow((1.0 - ((alpha + t) * (alpha / n))), -n); //slightly more stable version of above
  }
   */

  double DSCB_norm( const double alpha_low, const double n_low,
                    const double alpha_high, const double n_high )
  {
    assert( alpha_low > 0 );
    assert( alpha_high > 0 );
    assert( n_low > 1 );
    assert( n_high > 1 );
    
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
    const double root_pi = boost::math::constants::root_pi<double>();
    
    
    double a = alpha_low;
    double n = n_low;
    // -(e^(-a*a/2)*n*((a*(-t+n/a-a))/n)^(1-n))/(a*(1-n))
    // -(e^(-a^2/2)*n^n*(-t+n/a-a)^(1-n))/((1-n)*a^n)
    //const double ltail = -(std::exp(-a*a/2)*n*std::pow((a*(a +n/a -a))/n,1-n))/(a*(1-n)); //From Integrating with Maxima
    const double ltail = -std::exp(-0.5*a*a) * n / (a * (1.0 - n)); //Simplifying, and making more numerically stable, using https://herbie.uwplse.org/demo/
    
    // L = alpha_low
    // R = alpha_high
    // (sqrt(pi)*(erf(R/sqrt(2))-erf(L/sqrt(2))))/sqrt(2)
    const double mid = (root_pi*one_div_root_two*(boost_erf_imp(alpha_high*one_div_root_two)
                                                   - boost_erf_imp(-alpha_low*one_div_root_two)));
    
    a = alpha_high;
    n = n_high;
    // Integrate [e^(-a^2/2)* (((a/n)*((n/a)-a+t))^(-n)] dt, from a to inifit
    // (e^(-a^2/2)*n*((a*(t+n/a-a))/n)^(1-n))/(a*(1-n))
    // (e^(-a^2/2)*n^n*(x+n/a-a)^(1-n))/((1-n)*a^n)
    //const double rtail = -(std::exp(-a*a/2)*n*std::pow((a*(a + n/a -a))/n,1-n))/(a*(1-n)); //From Integrating with Maxima
    const double rtail = -std::exp(-0.5*a*a) * n / (a * (1.0 - n));  //Simplifying, and making more numerically stable, using https://herbie.uwplse.org/demo/
    
    return 1.0 / (ltail + mid + rtail);
  }//DSCB_norm( ... )
  
  
  double DSCB_left_tail_indefinite_non_norm_t( const double alpha_low,
                                                          const double n_low,
                                                          const double t)
  {
    // Takes `t = (x - mean) / sigma`, not x
    assert( t <= -alpha_low );
    
    const double &a = alpha_low;
    const double &n = n_low;
    //return -(std::exp(-a*a/2)*n*std::pow((a*(-t+n/a-a))/n, 1-n))/(a*(1-n));
    const double t_1 = 1.0 - (a / (n / (a + t)));
    return -std::exp(-0.5*a*a)*(t_1 / std::pow(t_1, n)) / ((a / n) - a); //slightly more stable
  }//double DSCB_left_tail_indefinite_non_norm_t(t)
  
  
  double DSCB_right_tail_indefinite_non_norm_t( const double alpha_high,
                                                           const double n_high,
                                                           const double t)
  {
    // Takes `t = (x - mean) / sigma`, not x
    assert( (t + 1.0E-7) >= alpha_high );
    
    const double &a = alpha_high;
    const double &n = n_high;
    
    // (e^(a^2/2)*n*((a*(t+n/a-a))/n)^(1-n))/(a*(1-n))
    //return (std::exp(-a*a/2)*n*std::pow((a*(t + n/a - a))/n,1-n))/(a*(1-n));
    return std::exp(-a*a/2)*(1.0 / ((a / n) - a)) * std::pow((1.0 + ((a * (t - a)) / n)), (1.0 - n));
  }
  
  double DSCB_gauss_indefinite_non_norm_t( const double t )
  {
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
    
    return root_half_pi * boost_erf_imp( one_div_root_two * t );
  }//DSCB_gauss_indefinite_non_norm_t(...)

  
  /** Returns the normalization so the GaussExp distribution has unit area. */
  double gauss_exp_norm( const double sigma, const double skew )
  {
    static const double sqrt_pi = boost::math::constants::root_pi<double>(); //1.7724538509055160272981
    static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    
    return 1.0 / ((sigma/skew)*std::exp(-0.5*skew*skew)
           + (sqrt_pi*one_div_root_two*(boost_erf_imp(skew*one_div_root_two)+1)*sigma));
  }
  
  double gauss_exp_pdf(const double mean,
                       const double sigma,
                       const double skew,
                       const double x )
  {
    const double t = (x - mean) / sigma;
    const double norm = gauss_exp_norm( sigma, skew );
    if( t >= -skew )
      return norm * std::exp( -0.5*t*t );
    return norm * std::exp( 0.5*skew*skew + skew*t );
  }
  
  double gauss_exp_tail_indefinite(const double mean,
                                  const double sigma,
                                  const double skew,
                                  const double x )
  {
    const double t = (x - mean) / sigma;
    assert( t <= skew );
    
    return gauss_exp_norm(sigma,skew)*(sigma/skew)*std::exp((skew/sigma)*(0.5*skew*sigma - mean + x));
  }
  
  double gauss_exp_indefinite(const double mean,
                             const double sigma,
                             const double skew,
                             const double x )
  {
    const double t = (x - mean) / sigma;
    
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    
    double answer = gauss_exp_tail_indefinite( mean, sigma, skew, std::min(x,-skew*sigma + mean) );
    if( t >= -skew )
      answer += gauss_exp_norm(sigma,skew)*sigma*root_half_pi
                 * (boost_erf_imp(t*one_div_root_two) - boost_erf_imp(-skew*one_div_root_two) );
    return answer;
  }
  
  
  double gauss_exp_integral( const double mean, const double sigma, const double skew, const double x1, const double x2 )
  {
    return gauss_exp_indefinite(mean, sigma, skew, x2) - gauss_exp_indefinite(mean, sigma, skew, x1);
  }
      
  
  double exp_gauss_exp_norm( const double sigma, const double skew_left, const double skew_right )
  {
    static const double sqrt_pi = boost::math::constants::root_pi<double>(); //1.7724538509055160272981
    static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    
    return 1.0 / ((sigma/skew_left)*std::exp(-0.5*skew_left*skew_left)
                  + (one_div_root_two*sqrt_pi*sigma*(boost_erf_imp(one_div_root_two*skew_right)+boost_erf_imp(one_div_root_two*skew_left)))
                  + (sigma/skew_right)*std::exp(-0.5*skew_right*skew_right) );
  }//exp_gauss_exp_norm(...)

  
  double exp_gauss_exp_pdf( const double mean,
                           const double sigma,
                           const double skew_left,
                           const double skew_right,
                           const double x )
  {
    const double t = (x - mean) / sigma;
    const double norm = exp_gauss_exp_norm( sigma, skew_left, skew_right );
    if( t > skew_right )
      return norm*std::exp( 0.5*skew_right*skew_right - skew_right*t );
    
    if( t > -skew_left )
      return norm*std::exp( -0.5*t*t );
      
    return norm*std::exp( 0.5*skew_left*skew_left + skew_left*t );
  }//double exp_gauss_exp_pdf(...)
  

  double exp_gauss_exp_left_tail_indefinite( const double mean,
                                          const double sigma,
                                          const double skew_left,
                                          const double skew_right,
                                          const double x )
  {
    //const double t = (x - mean) / sigma;
    const double norm = exp_gauss_exp_norm(sigma,skew_left,skew_right);
    return norm*(sigma/skew_left)*std::exp((skew_left/sigma)*(0.5*skew_left*sigma - mean + x));
  }

  double exp_gauss_exp_right_tail_indefinite( const double mean,
                                           const double sigma,
                                           const double skew_left,
                                           const double skew_right,
                                           const double x )
  {
    const double norm = exp_gauss_exp_norm( sigma, skew_left, skew_right );
    const double &k = skew_right;
    const double &s = sigma;
    const double &m = mean;
    return norm*((std::exp(-k*k/2)*s)/k-(s*std::exp((k*m)/s-(x*k)/s+k*k/2))/k);
  }

  double exp_gauss_exp_gauss_indefinite( const double mean,
                                      const double sigma,
                                      const double skew_left,
                                      const double skew_right,
                                      const double x )
  {
    static const double sqrt_pi = boost::math::constants::root_pi<double>(); //1.7724538509055160272981
    static const double root_half_pi = boost::math::constants::root_half_pi<double>(); //1.2533141373155002512078826424
    static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    
    const double t = (x - mean) / sigma;
    const double norm = exp_gauss_exp_norm( sigma, skew_left, skew_right);
    
    return norm * sigma * root_half_pi * (boost_erf_imp( one_div_root_two*t )
                                          - boost_erf_imp( -one_div_root_two*skew_left ) );
  }//
  
  double exp_gauss_exp_indefinite( const double mean,
                                const double sigma,
                                const double skew_left,
                                const double skew_right,
                                const double x )
  {
    const double t = (x - mean) / sigma;
    double answer = exp_gauss_exp_left_tail_indefinite( mean, sigma, skew_left, skew_right, min(x,-skew_left*sigma + mean) );
    
    if( t > skew_right )
      answer += exp_gauss_exp_right_tail_indefinite( mean, sigma, skew_left, skew_right, x );
    
    if( t > -skew_left )
      answer += exp_gauss_exp_gauss_indefinite( mean, sigma, skew_left, skew_right, min(x,skew_right*sigma + mean) );
    
    return answer;
  }
  
  double exp_gauss_exp_integral(const double mean,
                           const double sigma,
                           const double skew_left,
                           const double skew_right,
                           const double x0,
                           const double x1 )
  {
    return exp_gauss_exp_indefinite(mean, sigma, skew_left, skew_right,x1)
        - exp_gauss_exp_indefinite(mean, sigma, skew_left, skew_right, x0);
  }
  
  
  double gaussian_integral( const double peak_mean, const double peak_sigma,
                            const double x0, const double x1 )
  {
    if( peak_sigma == 0.0 )
      return 0.0;

    const double sqrt2 = boost::math::constants::root_two<double>();  //M_SQRT2 (but need to use '#define _USE_MATH_DEFINES' before #include <cmath>)
    
    const double erflowarg = (x0 - peak_mean)/(sqrt2*peak_sigma);
    const double erfhigharg = (x1 - peak_mean)/(sqrt2*peak_sigma);
    
    return 0.5 * (boost_erf_imp(erfhigharg) - boost_erf_imp(erflowarg));
  }//double gaussian_integral(...)


  void gaussian_integral( const double peak_mean,
                              const double peak_sigma,
                              const double peak_amplitude,
                              const float * const energies,
                              double *channels,
                              const size_t nchannel )
  {
    if( peak_sigma==0.0 || peak_amplitude==0.0 )
      return;
    
    const double zero_amp_point_nsigma = 8.0;
    const float start_energy = static_cast<float>( peak_mean - zero_amp_point_nsigma*peak_sigma );
    const float stop_energy = static_cast<float>( peak_mean + zero_amp_point_nsigma*peak_sigma );
    
    size_t channel = 0;
    while( (channel < nchannel) && (energies[channel+1] < start_energy) )
    {
      channel += 1;
    }
    
    if( channel == nchannel )
      return;
    
    const double sqrt2 = boost::math::constants::root_two<double>();
    
    // We will keep track of the channels lower value of erf, so we dont have to re-compute
    //  it for each channel (this is the who advantage of )
    double erflow = boost_erf_imp( (energies[channel] - peak_mean)/(sqrt2*peak_sigma) );
    
    while( (channel < nchannel) && (energies[channel] < stop_energy) )
    {
      const double erfhigharg = (energies[channel+1] - peak_mean)/(sqrt2*peak_sigma);
      const double erfhigh = boost_erf_imp( erfhigharg );
      
      channels[channel] += 0.5 * peak_amplitude * (erfhigh - erflow);
      channel += 1;
      erflow = erfhigh;
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
  }//gaus_integral(...)

  
  
  
  void bortel_integral( const double mean, const double sigma, const double amp, const double skew,
                       const float * const energies, double *channels, const size_t nchannel )
  {
    assert( sigma > 0.0 );
    if( (sigma <= 0.0) || (amp <= 0.0) || !nchannel )
      return;
    
    const double zero_amp_point_nsigma_lower = 12.0; // TODO: Use the skew to determine lower energy
    const double zero_amp_point_nsigma_upper = 8.0;
    const float start_energy = static_cast<float>( mean - zero_amp_point_nsigma_lower*sigma );
    const float stop_energy = static_cast<float>( mean + zero_amp_point_nsigma_upper*sigma );
    
    size_t channel = 0;
    while( (channel < nchannel) && (energies[channel+1] < start_energy) )
    {
      channel += 1;
    }
    
    if( channel == nchannel )
      return;
    
    // We will keep track of the channels lower value indefinite integral, so we dont have to
    //  re-compute it for each channel
    double val_low = bortel_indefinite_integral(energies[channel], mean, sigma, skew );
    
    while( (channel < nchannel) && (energies[channel] < stop_energy) )
    {
      const double val_high = bortel_indefinite_integral(energies[channel+1], mean, sigma, skew );
      
      channels[channel] += amp*(val_high - val_low);
      val_low = val_high;
      channel += 1;
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
  }//bortel_integral( to array values)


  
  double crystal_ball_integral( const double mean,
                               const double sigma,
                               const double alpha,
                               const double n,
                               const double x0, const double x1 )
  {
    // TODO: this is just a niave implementation - still needs to be optimized
    
    // Also, the implementation in CERNs ROOT
    //  may better deal with numerical accuracies of tails by switching to integrating in log
    //   see https://root.cern.ch/doc/master/RooCrystalBall_8cxx_source.html
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    
    const double a_0 = (x0 - mean) / sigma;
    const double a_1 = (x1 - mean) / sigma;
    
    if( (a_0 <= -alpha) && (a_1 <= -alpha) )
    {
      // Integrate just among the power law component
      return (crystal_ball_tail_indefinite_t(sigma,alpha,n,a_1)
                               - crystal_ball_tail_indefinite_t(sigma,alpha,n,a_0));
    }
    
    const double A = std::pow(n/alpha, n) * std::exp( -0.5*alpha*alpha );
    //const double B = (n / alpha) - alpha;
    const double C = (n / alpha) * (1.0/(n - 1.0)) * std::exp( -0.5*alpha*alpha );
    const double D = root_half_pi * (1.0 + boost_erf_imp( one_div_root_two * alpha ));
    //const double N = 1.0 / (sigma * (C + D));
    
    const double sqrt_2pi = boost::math::constants::root_two_pi<double>();
    
    const double gauss_amp = sqrt_2pi / (C + D);
    
    if( (a_0 >= -alpha) && (a_1 > -alpha) ) // just the gaussian
      return gauss_amp*gaussian_integral( mean, sigma, x0, x1 );
    
    // integrate power-law from a_0 to -alpha
    // integrate gaussian from -alpha to a_1
    return (crystal_ball_tail_indefinite_t(sigma,alpha,n,-alpha)
                             - crystal_ball_tail_indefinite_t(sigma,alpha,n,a_0))
    + gauss_amp*gaussian_integral( mean, sigma, mean-alpha*sigma, x1 );
  }//crystal_ball_integral(...)

  
  double double_sided_crystal_ball_integral( const double peak_mean,
                                            const double peak_sigma,
                                            const double alpha_low,
                                            const double n_low,
                                            const double alpha_high,
                                            const double n_high,
                                            const double x0, const double x1 )
  {
#ifdef _MSC_VER
#pragma message( "PeakDef::double_sided_crystal_ball_integral not tested/optimized - normalization for power law below 5 starts being off decently" )
#else
#warning "PeakDef::double_sided_crystal_ball_integral not tested/optimized - normalization for power law below 5 starts being off decently"
#endif
    
    const double t0 = (x0 - peak_mean) / peak_sigma;
    const double t1 = (x1 - peak_mean) / peak_sigma;
    
    double answer = 0.0;
    if( t0 < -alpha_low )
      answer += DSCB_left_tail_indefinite_non_norm_t( alpha_low, n_low, std::min(-alpha_low,t1) )
      - DSCB_left_tail_indefinite_non_norm_t( alpha_low, n_low, t0 );
    
    if( t1 > alpha_high )
      answer += DSCB_right_tail_indefinite_non_norm_t( alpha_high, n_high, t1 )
      - DSCB_right_tail_indefinite_non_norm_t( alpha_high, n_high, std::max(alpha_high,t0) );
    
    if( (t0 < alpha_high) && (t1 > -alpha_low) )
      answer += DSCB_gauss_indefinite_non_norm_t( min(alpha_high,t1) )
      - DSCB_gauss_indefinite_non_norm_t( max(-alpha_low,t0) );
    
    const double norm = DSCB_norm( alpha_low, n_low, alpha_high, n_high );
    return norm*answer;
  }//double_sided_crystal_ball_integral(...)

  
  
  
  void gauss_exp_integral( const double peak_mean,
                          const double peak_sigma,
                          const double peak_amplitude,
                          const double skew,
                          const float * const energies,
                          double *channels,
                          const size_t nchannel )
  {
#define USE_SIMPLE_GAUSS_EXP_IMP 0
    
#if( USE_SIMPLE_GAUSS_EXP_IMP )
    //compiled in debug mode, this implementation takes about 5 times as long as the more optimized version.
    
#ifdef _MSC_VER
#pragma message( "PeakDef::gauss_exp_integral is not properly coded" )
#else
#warning "PeakDef::gauss_exp_integral is not properly coded"
#endif
    
#if( PERFORM_DEVELOPER_CHECKS )
    double dist_sum = 0.0;
#endif
    
    for( size_t i = 0; i < nchannel; ++i )
    {
      const float x0 = energies[i];
      const float x1 = energies[i+1];
      const double val = peak_amplitude*PeakDists::gauss_exp_integral( peak_mean, peak_sigma, skew, x0, x1 );
      channels[i] += val;
      
#if( PERFORM_DEVELOPER_CHECKS )
      dist_sum += val;
      
      if( IsInf(channels[i]) || IsNan(channels[i]) )
      {
        cerr << "Found GausExp invalid counts, " << channels[i] << " from [" << x0 << ", " << x1 << "]:\n"
        << "\t" << setw(14) << "range:" << "[" << energies[0] << ", " << energies[nchannel] << "]\n"
        << "\t" << setw(14) << "min_energy =" << energies[0] << "\n"
        << "\t" << setw(14) << "max_energy =" << energies[nchannel] << "\n"
        << "\t" << setw(14) << "nchannel =" << nchannel << "\n"
        << "\t" << setw(14) << "mean =" << peak_mean << "\n"
        << "\t" << setw(14) << "sigma =" << peak_sigma << "\n"
        << "\t" << setw(14) << "amp =" << peak_amplitude << "\n"
        << "\t" << setw(14) << "skew =" << skew << "\n"
        << endl;
        cerr << endl;
      }//if( skew_type_t != PeakDef::NoSkew )
      
      //log_developer_error( __func__, "Invalid CSS color called back " );
#endif //PERFORM_DEVELOPER_CHECKS
    }
    
#if( PERFORM_DEVELOPER_CHECKS )
    //  cerr << "GaussExp sum over [" << energies[0] << "," << energies[nchannel] << "] is "
    //  << (dist_sum/peak_amplitude) << " (should be near 1)" << endl;
#endif
    
#else  //USE_SIMPLE_GAUSS_EXP_IMP
    
    if( (peak_sigma == 0.0) || (peak_amplitude == 0.0) )
      return;
    
    
    // TODO: estimate where we should actually start and stop computing values for, using `gauss_exp_coverage_limits(...)`, but need to check if it actually saves time
    const double zero_amp_point_nsigma = 8.0;
    const float start_energy = energies[0]; //static_cast<float>( peak_mean - zero_amp_point_nsigma*peak_sigma );
    const float stop_energy = static_cast<float>( peak_mean + zero_amp_point_nsigma*peak_sigma );
    
    size_t channel = 0;
    while( (channel < nchannel) && (energies[channel+1] < start_energy) )
    {
      channel += 1;
    }
    
    if( channel == nchannel )
      return;
    
    
    const auto tail_indefinite_non_norm = [peak_mean,peak_sigma,skew]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      assert( (t - 1.0E-8) <= -skew );
      return (peak_sigma/skew)*std::exp((skew/peak_sigma)*(0.5*skew*peak_sigma - peak_mean + x));
    };
    
    const auto gaus_indefinite_non_norm = [peak_mean,peak_sigma,skew]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      assert( (t + 1.0E-6) >= -skew );
      
      const double root_half_pi = boost::math::constants::root_half_pi<double>();
      static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
      return peak_sigma*root_half_pi * boost_erf_imp(t*one_div_root_two);
    };
    
    const double norm = peak_amplitude * gauss_exp_norm( peak_sigma, skew );
    const double tail_end = peak_mean - peak_sigma*skew;
    
    
    if( energies[channel] < tail_end )
    {
      double indefinite_low = tail_indefinite_non_norm( energies[channel] );
      
      while( (channel < nchannel) && (energies[channel] < tail_end) )
      {
        const double upper_energy = energies[channel+1];
        
        double indefinite_high;
        if( upper_energy > tail_end )
        {
          indefinite_high = tail_indefinite_non_norm( tail_end );
          channels[channel] += norm * (indefinite_high - indefinite_low);
          break;
        }else
        {
          indefinite_high = tail_indefinite_non_norm( upper_energy );
          channels[channel] += norm * (indefinite_high - indefinite_low);
          indefinite_low = indefinite_high;
          channel += 1;
        }
      }//while( (channel < nchannel) && (energies[channel] < tail_end) )
    }//if( energies[channel] < tail_end )
    
    if( channel >= nchannel )
      return;
    
    assert( energies[channel+1] >= tail_end );
    double indefinite_low = gaus_indefinite_non_norm( std::max(1.0*energies[channel],tail_end) );
    
    while( (channel < nchannel) && (energies[channel] < stop_energy) )
    {
      const double upper_energy = energies[channel+1];
      const double indefinite_high = gaus_indefinite_non_norm( upper_energy );
      
      channels[channel] += norm * (indefinite_high - indefinite_low);
      indefinite_low = indefinite_high;
      channel += 1;
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
#endif  //USE_SIMPLE_GAUSS_EXP_IMP
  }//void PeakDef::gauss_exp_integral( ... array ... )
  
  
  void exp_gauss_exp_integral( const double peak_mean,
                              const double peak_sigma,
                              const double peak_amplitude,
                              const double skew_left,
                              const double skew_right,
                              const float * const energies,
                              double *channels,
                              const size_t nchannel )
  {
#define USE_SIMPLE_EGE_IMP 0
    
#if( USE_SIMPLE_EGE_IMP )
#ifdef _MSC_VER
#pragma message( "PeakDef::exp_gauss_exp_integral is not properly coded" )
#else
#warning "PeakDef::exp_gauss_exp_integral is not properly coded"
#endif
    
    for( size_t i = 0; i < nchannel; ++i )
    {
      const float x0 = energies[i];
      const float x1 = energies[i+1];
      
      channels[i] += peak_amplitude*PeakDists::exp_gauss_exp_integral( peak_mean, peak_sigma, skew_left, skew_right, x0, x1 );
      
#if( PERFORM_DEVELOPER_CHECKS )
      if( IsInf(channels[i]) || IsNan(channels[i]) )
      {
        cerr << "Found ExpGausExp invalid counts, " << channels[i] << " from [" << x0 << ", " << x1 << "]:\n"
        << "\t" << setw(14) << "range:" << "[" << energies[0] << ", " << energies[nchannel] << "]\n"
        << "\t" << setw(14) << "min_energy =" << energies[0] << "\n"
        << "\t" << setw(14) << "max_energy =" << energies[nchannel] << "\n"
        << "\t" << setw(14) << "nchannel =" << nchannel << "\n"
        << "\t" << setw(14) << "mean =" << peak_mean << "\n"
        << "\t" << setw(14) << "sigma =" << peak_sigma << "\n"
        << "\t" << setw(14) << "amp =" << peak_amplitude << "\n"
        << "\t" << setw(14) << "skew_left =" << skew_left << "\n"
        << "\t" << setw(14) << "skew_right =" << skew_right << "\n"
        << endl;
        cerr << endl;
      }//if( skew_type_t != PeakDef::NoSkew )
      
      //log_developer_error( __func__, "Invalid CSS color called back " );
#endif //PERFORM_DEVELOPER_CHECKS
    }//for( size_t i = 0; i < nchannel; ++i )
    
#else
    
    if( (peak_sigma == 0.0) || (peak_amplitude == 0.0) )
      return;
    
    
    // TODO: estimate where we should actually start and stop computing values for, using `exp_gauss_exp_coverage_limits(...)`, but need to check if it actually saves time
    //const double zero_amp_point_nsigma = 8.0;
    const float start_energy = energies[0]; //static_cast<float>( peak_mean - zero_amp_point_nsigma*peak_sigma );
    const float stop_energy = energies[nchannel]; //static_cast<float>( peak_mean + zero_amp_point_nsigma*peak_sigma );
    
    size_t channel = 0;
    while( (channel < nchannel) && (energies[channel+1] < start_energy) )
    {
      channel += 1;
    }
    
    if( channel == nchannel )
      return;

    
    auto left_tail_indefinite_non_norm = [peak_mean,peak_sigma,skew_left]( const double x ) -> double {
      return (peak_sigma/skew_left)*std::exp((skew_left/peak_sigma)*(0.5*skew_left*peak_sigma - peak_mean + x));
    };
    
    const double r_const = (std::exp(-0.5*skew_right*skew_right/2)*peak_sigma)/skew_right;
    auto right_tail_indefinite_non_norm = [peak_mean,peak_sigma,skew_right,r_const]( const double x ) -> double {
      return (r_const-(peak_sigma*std::exp((skew_right*peak_mean)/peak_sigma-(x*skew_right)/peak_sigma+0.5*skew_right*skew_right))/skew_right);
    };
    
    auto gauss_indefinite_non_norm = [peak_mean,peak_sigma]( const double x ) -> double {
      static const double root_half_pi = boost::math::constants::root_half_pi<double>(); //1.2533141373155002512078826424
      static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
      
      const double t = (x - peak_mean) / peak_sigma;
      return peak_sigma * root_half_pi * boost_erf_imp( one_div_root_two*t );
    };
    
    const double norm = peak_amplitude * exp_gauss_exp_norm( peak_sigma, skew_left, skew_right );
    
    const double left_tail_end = peak_mean - peak_sigma*skew_left;
    const double right_tail_start = peak_mean + peak_sigma*skew_right;
    
    
    if( energies[channel] < left_tail_end )
    {
      double indefinite_low = left_tail_indefinite_non_norm( energies[channel] );
      
      while( (channel < nchannel) && (energies[channel] < left_tail_end) )
      {
        const double upper_energy = energies[channel+1];
        
        if( upper_energy > left_tail_end )
        {
          const double indefinite_high = left_tail_indefinite_non_norm( left_tail_end );
          channels[channel] += norm * (indefinite_high - indefinite_low);
          break;
        }else
        {
          const double indefinite_high = left_tail_indefinite_non_norm( upper_energy );
          channels[channel] += norm * (indefinite_high - indefinite_low);
          indefinite_low = indefinite_high;
          channel += 1;
        }
      }//while( (channel < nchannel) && (energies[channel] < tail_end) )
    }//if( energies[channel] < tail_end )
    
    if( channel >= nchannel )
      return;
    
    assert( energies[channel+1] >= left_tail_end );
    double indefinite_low = gauss_indefinite_non_norm( std::max(1.0*energies[channel],left_tail_end) );
    
    while( (channel < nchannel) && (energies[channel] < right_tail_start) )
    {
      const double upper_energy = energies[channel+1];
      
      if( upper_energy > right_tail_start )
      {
        const double indefinite_high = gauss_indefinite_non_norm( right_tail_start );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        break;
      }else
      {
        const double indefinite_high = gauss_indefinite_non_norm( upper_energy );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        indefinite_low = indefinite_high;
        channel += 1;
      }
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
    
    
    if( channel >= nchannel )
      return;
    
    assert( energies[channel+1] >= right_tail_start );
    indefinite_low = right_tail_indefinite_non_norm( std::max(1.0*energies[channel],right_tail_start) );
    
    while( (channel < nchannel) && (energies[channel] < stop_energy) )
    {
      const double upper_energy = energies[channel+1];
      
      if( upper_energy > stop_energy )
      {
        const double indefinite_high = right_tail_indefinite_non_norm( right_tail_start );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        break;
      }else
      {
        const double indefinite_high = right_tail_indefinite_non_norm( upper_energy );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        indefinite_low = indefinite_high;
        channel += 1;
      }
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
#endif
  }

  
  void crystal_ball_integral( const double peak_mean,
                             const double peak_sigma,
                             const double peak_amplitude,
                             const double alpha,
                             const double power_law,
                             const float * const energies,
                             double *channels,
                             const size_t nchannel )
  {
#define USE_SIMPLE_CB_IMP 0
    
#if( PERFORM_DEVELOPER_CHECKS )
    double dist_sum = 0.0;
#endif

    
#if( USE_SIMPLE_CB_IMP )
    for( size_t i = 0; i < nchannel; ++i )
    {
      const float x0 = energies[i];
      const float x1 = energies[i+1];
      
      const double val = peak_amplitude*PeakDists::crystal_ball_integral( peak_mean, peak_sigma, alpha, power_law, x0, x1 );
      channels[i] += val;
      
#if( PERFORM_DEVELOPER_CHECKS )
      dist_sum += val;
#endif
      
#if( PERFORM_DEVELOPER_CHECKS )
      if( IsInf(channels[i]) || IsNan(channels[i]) )
      {
        cerr << "Found Crystal Ball invalid counts, " << channels[i] << " from [" << x0 << ", " << x1 << "]:\n"
        << "\t" << setw(14) << "range:" << "[" << energies[0] << ", " << energies[nchannel] << "]\n"
        << "\t" << setw(14) << "min_energy =" << energies[0] << "\n"
        << "\t" << setw(14) << "max_energy =" << energies[nchannel] << "\n"
        << "\t" << setw(14) << "nchannel =" << nchannel << "\n"
        << "\t" << setw(14) << "mean =" << peak_mean << "\n"
        << "\t" << setw(14) << "sigma =" << peak_sigma << "\n"
        << "\t" << setw(14) << "amp =" << peak_amplitude << "\n"
        << "\t" << setw(14) << "alpha =" << alpha << "\n"
        << "\t" << setw(14) << "n =" << power_law << "\n"
        << endl;
        cerr << endl;
      }//if( skew_type_t != PeakDef::NoSkew )
      
      //log_developer_error( __func__, "..." );
#endif //PERFORM_DEVELOPER_CHECKS
    }//for( size_t i = 0; i < nchannel; ++i )
    

#else //USE_SIMPLE_CB_IMP
    
    
    if( (peak_sigma == 0.0) || (peak_amplitude == 0.0) )
      return;
    
    
     // TODO: estimate where we should actually start and stop computing values for, using `crystal_ball_coverage_limits(...)`, but need to check if it actually saves time
    const double zero_amp_point_nsigma = 8.0;
    const float start_energy = energies[0]; //static_cast<float>( peak_mean - zero_amp_point_nsigma*peak_sigma );
    const float stop_energy = static_cast<float>( peak_mean + zero_amp_point_nsigma*peak_sigma );
    
    size_t channel = 0;
    while( (channel < nchannel) && (energies[channel+1] < start_energy) )
    {
      channel += 1;
    }
    
    if( channel == nchannel )
      return;
    
    
    const double exp_aa = std::exp(-0.5*alpha*alpha);
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    const double sqrt_2pi = boost::math::constants::root_two_pi<double>();
    
    const double A = std::pow(power_law/alpha, power_law) * exp_aa;
    const double B = (power_law / alpha) - alpha;
    const double C = (power_law / alpha) * (1.0/(power_law - 1.0)) * exp_aa;
    const double D = root_half_pi * (1.0 + boost_erf_imp( one_div_root_two * alpha ));
    const double N = 1.0 / (peak_sigma * (C + D));
    const double tail_amp = peak_amplitude * N * A * peak_sigma / (power_law - 1.0);
    const double gauss_indef_amp = 0.5 * peak_amplitude * sqrt_2pi / (C + D);
    
    // Brief implementation of crystal_ball_tail_indefinite_t
    auto tail_indefinite = [peak_mean,peak_sigma,alpha,power_law,B,tail_amp]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      assert( ((t - 1.0E-6) <= -alpha) && (alpha > 0.0) && (power_law > 1.0) );
      return tail_amp * std::pow( B - t, 1.0 - power_law );
    };
    
    auto gauss_indefinite = [peak_mean,peak_sigma,gauss_indef_amp,one_div_root_two]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      return gauss_indef_amp * boost_erf_imp( one_div_root_two * t );
    };
    
    
    const double tail_end = peak_mean - peak_sigma*alpha;    
    
    if( energies[channel] < tail_end )
    {
      double indefinite_low = tail_indefinite( energies[channel] );
      
      while( (channel < nchannel) && (energies[channel] < tail_end) )
      {
        assert( energies[channel] < energies[channel+1] );
        
        const double upper_energy = energies[channel+1];
        
        if( upper_energy > tail_end )
        {
          const double indefinite_high = tail_indefinite( tail_end );
          const double val = (indefinite_high - indefinite_low);
          channels[channel] += val;
    #if( PERFORM_DEVELOPER_CHECKS )
          dist_sum += val;
    #endif
          break;
        }else
        {
          const double indefinite_high = tail_indefinite( upper_energy );
          const double val = (indefinite_high - indefinite_low);
          channels[channel] += val;
          indefinite_low = indefinite_high;
          channel += 1;
        }
      }//while( (channel < nchannel) && (energies[channel] < tail_end) )
    }//if( energies[channel] < tail_end )
    
    if( channel >= nchannel )
      return;
    
    assert( energies[channel+1] >= tail_end );
    double indefinite_low = gauss_indefinite( std::max(1.0*energies[channel],tail_end) );
    
    while( (channel < nchannel) && (energies[channel] < stop_energy) )
    {
      assert( energies[channel] < energies[channel+1] );
      const double upper_energy = energies[channel+1];
      
      const double indefinite_high = gauss_indefinite( upper_energy );
      const double val = (indefinite_high - indefinite_low);
      channels[channel] += val;
      indefinite_low = indefinite_high;
      channel += 1;
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
#endif //USE_SIMPLE_CB_IMP
    
    
#if( PERFORM_DEVELOPER_CHECKS )
    /*
     const double frac = dist_sum / peak_amplitude;
     cerr << "Crystal Ball sum over [" << energies[0] << "," << energies[nchannel] << "] is "
     << frac << " (should be near 1)" << endl;
     
     if( fabs(1 - frac) > 0.01 )
     {
     cerr << "alpha(x) -> " << (peak_mean - alpha*peak_sigma) << endl;
     for( size_t i = 0; i < nchannel; ++i )
     cout << setw(5) << i << setw(12) << std::fixed << setprecision(2) << energies[i]
     << setw(12) << std::scientific << (channels[i]/peak_amplitude) << endl;
     
     cerr << "Single step integral is "
     << PeakDef::crystal_ball_integral( peak_mean, peak_sigma, 1.0, alpha, power_law, energies[0], energies[nchannel] )
     << " and over all area: "
     << PeakDef::crystal_ball_integral( peak_mean, peak_sigma, 1.0, alpha, power_law, peak_mean - 50*peak_sigma, peak_mean + 20*peak_sigma )
     << endl;
     }//if( fabs(1 - frac) > 0.01 )
     */
#endif
    
  }//crystal_ball_integral(...)

  
  void double_sided_crystal_ball_integral( const double peak_mean,
                                          const double peak_sigma,
                                          const double peak_amplitude,
                                          const double lower_alpha,
                                          const double lower_power_law,
                                          const double upper_alpha,
                                          const double upper_power_law,
                                          const float * const energies,
                                          double *channels,
                                          const size_t nchannel )
  {
#define USE_SIMPLE_DSCB_IMP 0
    
#if( USE_SIMPLE_DSCB_IMP )
    //compiled in debug mode, this implementation takes about X times as long as the more optimized version.
    
#ifdef _MSC_VER
#pragma message( "PeakDef::double_sided_crystal_ball_integral is not properly coded" )
#else
#warning "PeakDef::double_sided_crystal_ball_integral is not properly coded"
#endif
    
#if( PERFORM_DEVELOPER_CHECKS )
    double dist_sum = 0.0;
#endif
    
    for( size_t i = 0; i < nchannel; ++i )
    {
      const float x0 = energies[i];
      const float x1 = energies[i+1];
      
      const double val = peak_amplitude*PeakDists::double_sided_crystal_ball_integral( peak_mean, peak_sigma,
                                                                       lower_alpha, lower_power_law,
                                                                       upper_alpha, upper_power_law, x0, x1 );
      channels[i] += val;
      
#if( PERFORM_DEVELOPER_CHECKS )
      dist_sum += val;
      
      if( IsInf(channels[i]) || IsNan(channels[i]) )
      {
        cerr << "Found Double Sided Crystal Ball invalid counts, " << channels[i] << " from [" << x0 << ", " << x1 << "]:\n"
        << "\t" << setw(14) << "range:" << "[" << energies[0] << ", " << energies[nchannel] << "]\n"
        << "\t" << setw(14) << "min_energy =" << energies[0] << "\n"
        << "\t" << setw(14) << "max_energy =" << energies[nchannel] << "\n"
        << "\t" << setw(14) << "nchannel =" << nchannel << "\n"
        << "\t" << setw(14) << "mean =" << peak_mean << "\n"
        << "\t" << setw(14) << "sigma =" << peak_sigma << "\n"
        << "\t" << setw(14) << "amp =" << peak_amplitude << "\n"
        << "\t" << setw(14) << "lower_alpha =" << lower_alpha << "\n"
        << "\t" << setw(14) << "lower_power_law =" << lower_power_law << "\n"
        << "\t" << setw(14) << "upper_alpha =" << upper_alpha << "\n"
        << "\t" << setw(14) << "upper_power_law =" << upper_power_law << "\n"
        << endl;
        cerr << endl;
      }//if( skew_type_t != PeakDef::NoSkew )
      
      //log_developer_error( __func__, "..." );
#endif //PERFORM_DEVELOPER_CHECKS
    }
    
#if( PERFORM_DEVELOPER_CHECKS )
    const double frac = dist_sum / peak_amplitude;
    //cerr << "Double Sided Crystal Ball sum over [" << energies[0] << "," << energies[nchannel] << "] is "
    //<< frac << " (should be near 1)" << endl;
    
    if( fabs(1 - frac) > 0.01 )
    {
      cerr << "alpha_low(x) -> " << (peak_mean - lower_alpha*peak_sigma) << endl;
      cerr << "upper_alpha(x) -> " << (peak_mean - upper_alpha*peak_sigma) << endl;
      //for( size_t i = 0; i < nchannel; ++i )
      //  cout << setw(5) << i << setw(12) << std::fixed << setprecision(2) << energies[i]
      //  << setw(12) << std::scientific << (channels[i]/peak_amplitude) << endl;
      
      cerr << "Single step integral is "
      << PeakDists::double_sided_crystal_ball_integral(peak_mean, peak_sigma,
                                                       lower_alpha, lower_power_law,
                                                       upper_alpha, upper_power_law,
                                                       energies[0], energies[nchannel] )
      << " and over all area: "
      << PeakDists::double_sided_crystal_ball_integral(peak_mean, peak_sigma,
                                                       lower_alpha, lower_power_law,
                                                       upper_alpha, upper_power_law,
                                                       peak_mean - 50*peak_sigma, peak_mean + 30*peak_sigma )
      << endl;
    }//if( fabs(1 - frac) > 0.01 )
#endif
    
#else //USE_SIMPLE_DSCB_IMP
    
    
    if( (peak_sigma == 0.0) || (peak_amplitude == 0.0) )
      return;
    
    
    // TODO: estimate where we should actually start and stop computing values for, using `double_sided_crystal_ball_coverage_limits(...)`, but need to check if it actually saves time
    //const double zero_amp_point_nsigma = 8.0;
    const float start_energy = energies[0]; //static_cast<float>( peak_mean - zero_amp_point_nsigma*peak_sigma );
    const float stop_energy = energies[nchannel]; //static_cast<float>( peak_mean + zero_amp_point_nsigma*peak_sigma );
    
    size_t channel = 0;
    while( (channel < nchannel) && (energies[channel+1] < start_energy) )
    {
      channel += 1;
    }
    
    if( channel == nchannel )
      return;
    
    const double exp_lower_aa = std::exp(-0.5*lower_alpha*lower_alpha);
    const double exp_upper_aa = std::exp(-0.5*upper_alpha*upper_alpha);
    
    auto left_tail_indefinite_non_norm = [peak_mean,peak_sigma,lower_alpha,lower_power_law, exp_lower_aa]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      assert( (t - 1.0E-7) <= -lower_alpha );
      
      const double &a = lower_alpha;
      const double &n = lower_power_law;
      const double t_1 = 1.0 - (a / (n / (a + t)));
      return -exp_lower_aa*(t_1 / std::pow(t_1, n)) / ((a / n) - a); //slightly more stable
    };
    
    auto right_tail_indefinite_non_norm = [peak_mean,peak_sigma,upper_alpha,upper_power_law,exp_upper_aa]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      assert( (t + 1.0E-7) >= upper_alpha );
      
      const double &a = upper_alpha;
      const double &n = upper_power_law;

      return exp_upper_aa*(1.0 / ((a / n) - a)) * std::pow((1.0 + ((a * (t - a)) / n)), (1.0 - n));
    };
    
    
    auto gauss_indefinite_non_norm = [peak_mean,peak_sigma]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      const double root_half_pi = boost::math::constants::root_half_pi<double>();
      const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
      
      return root_half_pi * boost_erf_imp( one_div_root_two * t );
    };
    
    
    
    const double norm = peak_amplitude * DSCB_norm( lower_alpha, lower_power_law, upper_alpha, upper_power_law);
    
    const double left_tail_end = peak_mean - peak_sigma*lower_alpha;
    const double right_tail_start = peak_mean + peak_sigma*upper_alpha;
    
    
    if( energies[channel] < left_tail_end )
    {
      double indefinite_low = left_tail_indefinite_non_norm( energies[channel] );
      
      while( (channel < nchannel) && (energies[channel] < left_tail_end) )
      {
        const double upper_energy = energies[channel+1];
        
        if( upper_energy > left_tail_end )
        {
          const double indefinite_high = left_tail_indefinite_non_norm( left_tail_end );
          channels[channel] += norm * (indefinite_high - indefinite_low);
          break;
        }else
        {
          const double indefinite_high = left_tail_indefinite_non_norm( upper_energy );
          channels[channel] += norm * (indefinite_high - indefinite_low);
          indefinite_low = indefinite_high;
          channel += 1;
        }
      }//while( (channel < nchannel) && (energies[channel] < tail_end) )
    }//if( energies[channel] < tail_end )
    
    if( channel >= nchannel )
      return;
    
    assert( energies[channel+1] >= left_tail_end );
    double indefinite_low = gauss_indefinite_non_norm( std::max(1.0*energies[channel],left_tail_end) );
    
    while( (channel < nchannel) && (energies[channel] < right_tail_start) )
    {
      const double upper_energy = energies[channel+1];
      
      if( upper_energy > right_tail_start )
      {
        const double indefinite_high = gauss_indefinite_non_norm( right_tail_start );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        break;
      }else
      {
        const double indefinite_high = gauss_indefinite_non_norm( upper_energy );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        indefinite_low = indefinite_high;
        channel += 1;
      }
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
    
    
    if( channel >= nchannel )
      return;
    
    assert( energies[channel+1] >= right_tail_start );
    indefinite_low = right_tail_indefinite_non_norm( std::max(1.0*energies[channel],right_tail_start) );
    
    while( (channel < nchannel) && (energies[channel] < stop_energy) )
    {
      const double upper_energy = energies[channel+1];
      
      if( upper_energy > stop_energy )
      {
        const double indefinite_high = right_tail_indefinite_non_norm( right_tail_start );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        break;
      }else
      {
        const double indefinite_high = right_tail_indefinite_non_norm( upper_energy );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        indefinite_low = indefinite_high;
        channel += 1;
      }
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
#endif //USE_SIMPLE_DSCB_IMP
  }//double_sided_crystal_ball_integral(...)

}//namespace PeakDists
