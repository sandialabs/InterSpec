/* InterSpec: an application to analyze spectral gamma radiation data.
 
 Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
 (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
 Government retains certain rights in this software.
 For questions contact William Johnson via email at wcjohns@sandia.gov, or
 alternative emails of interspec@sandia.gov.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include "InterSpec_config.h"

#include <memory>
#include <iostream>

#include <boost/math/constants/constants.hpp>
#include <boost/math/special_functions/erf.hpp>
#include <boost/math/distributions/poisson.hpp>

#include "InterSpec/PeakDef.h"
#include "InterSpec/PeakDists.h"

using namespace std;


namespace PeakDists
{
  /** 20191230: wcjohns extracted the boost::math::erf() function implementation
   from boost 1.65.1 for double precision (53 bit mantissa) into this function,
   boost_erf_imp(). Removing some of the supporting code structure, and
   explicitly writing out the polynomial equation evaluation seems to speed
   things up by about a factor of ~3 over calling boost::math::erf().
   
   Using the commented out erf_approx() function looks to be about 25% faster than
   this boost version, but I havent carefully checked out the precision implications
   so not switching to it yet.
   
   Surprisingly, the erf() function is the major bottleneck for peak fitting.
   */
  double boost_erf_imp( double z )
  {
    /* Since this function is a (slight) modification of boost source code, it
     is subject to the Boost Version 1 Software License, whose text is:
     
     Boost Software License - Version 1.0 - August 17th, 2003
     
     Permission is hereby granted, free of charge, to any person or organization
     obtaining a copy of the software and accompanying documentation covered by
     this license (the "Software") to use, reproduce, display, distribute,
     execute, and transmit the Software, and to prepare derivative works of the
     Software, and to permit third-parties to whom the Software is furnished to
     do so, all subject to the following:
     
     The copyright notices in the Software and this entire statement, including
     the above license grant, this restriction and the following disclaimer,
     must be included in all copies of the Software, in whole or in part, and
     all derivative works of the Software, unless such copies or derivative
     works are solely in the form of machine-executable object code generated by
     a source language processor.
     
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
     SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
     FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
     ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     DEALINGS IN THE SOFTWARE.
     */
    if(z < 0)
      return -boost_erf_imp( -z );
    
    if( z < 0.5 )
    {
      if( z < 1e-10 )
      {
        return z * 1.125f + z * 0.003379167095512573896158903121545171688;
      }else
      {
        const double zz = z * z;
        const double P_eval = (((zz*-0.000322780120964605683831 + -0.00772758345802133288487)*zz + -0.0509990735146777432841)*zz + -0.338165134459360935041)*zz + 0.0834305892146531832907;
        const double Q_eval = (((zz*0.000370900071787748000569 + 0.00858571925074406212772)*zz + 0.0875222600142252549554)*zz + 0.455004033050794024546)*zz + 1.0;
        
        return z * (1.044948577880859375f + P_eval / Q_eval);
      }
    }else if( z < 5.8f )
    {
      if(z < 1.5f)
      {
        static const double Y = 0.405935764312744140625f;
        static const double P[] = { -0.098090592216281240205, 0.178114665841120341155,
          0.191003695796775433986, 0.0888900368967884466578, 0.0195049001251218801359,
          0.00180424538297014223957
        };
        static const double Q[] = { 1.0, 1.84759070983002217845,
          1.42628004845511324508, 0.578052804889902404909, 0.12385097467900864233,
          0.0113385233577001411017, 0.337511472483094676155e-5
        };
        
        const double zarg = z - 0.5;
        const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
        const double Q_eval = (((((Q[6]*zarg + Q[5])*zarg + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
        
        return 1 - (Y + P_eval / Q_eval) * (exp(-z * z) / z);
      }else if(z < 2.5f)
      {
        static const double Y = 0.50672817230224609375f;
        static const double P[] = { -0.0243500476207698441272, 0.0386540375035707201728,
          0.04394818964209516296, 0.0175679436311802092299, 0.00323962406290842133584,
          0.000235839115596880717416
        };
        static const double Q[] = { 1.0, 1.53991494948552447182, 0.982403709157920235114,
          0.325732924782444448493, 0.0563921837420478160373, 0.00410369723978904575884
        };
        
        const double zarg = z - 1.5;
        const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
        const double Q_eval = ((((zarg*Q[5] + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
        
        return 1 - (Y + P_eval / Q_eval) * (exp(-z * z) / z);
      }
      else if(z < 4.5f)
      {
        static const double Y = 0.5405750274658203125f;
        static const double P[] = { 0.00295276716530971662634, 0.0137384425896355332126,
          0.00840807615555585383007, 0.00212825620914618649141, 0.000250269961544794627958,
          0.113212406648847561139e-4
        };
        static const double Q[] = { 1.0, 1.04217814166938418171,
          0.442597659481563127003, 0.0958492726301061423444, 0.0105982906484876531489,
          0.000479411269521714493907
        };
        
        const double zarg = z - 3.5;
        const double P_eval = ((((zarg*P[5] + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
        const double Q_eval = ((((zarg*Q[5] + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
        
        return 1 - (Y + P_eval / Q_eval) * (exp(-z * z) / z);
      }else
      {
        static const double Y = 0.5579090118408203125f;
        static const double P[] = { 0.00628057170626964891937, 0.0175389834052493308818,
          -0.212652252872804219852, -0.687717681153649930619, -2.5518551727311523996,
          -3.22729451764143718517, -2.8175401114513378771
        };
        static const double Q[] = { 1.0, 2.79257750980575282228, 11.0567237927800161565,
          15.930646027911794143, 22.9367376522880577224, 13.5064170191802889145,
          5.48409182238641741584
        };
        
        const double zarg = 1.0 / z;
        const double P_eval = (((((P[6]*zarg + P[5])*zarg + P[4])*zarg + P[3])*zarg + P[2])*zarg + P[1])*zarg + P[0];
        const double Q_eval = (((((Q[6]*zarg + Q[5])*zarg + Q[4])*zarg + Q[3])*zarg + Q[2])*zarg + Q[1])*zarg + Q[0];
        
        return 1 - (Y + P_eval / Q_eval) * (exp(-z * z) / z);
      }
    }
    
    return 1;
  }//double boost_erf_imp( double z )
  
  
  /*
  double erf_approx( double x )
  {
    //https://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python#answer-457805
    // Error is less than 1.5 * 10-7 for all inputs
    // (originally from Handbook of Mathematical Functions)
    const double sign = (x >= 0) ? 1 : -1;
    x = fabs(x);
    const double t = 1.0/(1.0 + 0.3275911*x);
    const double y = 1.0 - (((((1.061405429 * t + -1.453152027) * t) + 1.421413741) * t + -0.284496736) * t + 0.254829592) * t * std::exp(-x * x);
    return sign * y;
  }
   */
  
  double boost_erfc_imp( double z )
  {
    return 1.0 - boost_erf_imp( z );
  }
   
  void photopeak_function_integral( const double mean,
                                          const double sigma,
                                          const double amp,
                                          const PeakDef::SkewType skew_type,
                                          const double * const skew_parameters,
                                          const size_t nchannel,
                                          const float * const energies,
                                          double *channels )
  {
    assert( (skew_type == PeakDef::SkewType::NoSkew) || skew_parameters );
    
    switch( skew_type )
    {
      case PeakDef::SkewType::NoSkew:
        gaussian_integral( mean, sigma, amp, energies, channels, nchannel );
        break;
        
      case PeakDef::SkewType::Bortel:
        bortel_integral( mean, sigma, amp, skew_parameters[0], energies, channels, nchannel );
        break;
        
      case PeakDef::SkewType::CrystalBall:
        crystal_ball_integral( mean, sigma, amp, skew_parameters[0], skew_parameters[1], energies, channels, nchannel );
        break;
        
      case PeakDef::SkewType::DoubleSidedCrystalBall:
        double_sided_crystal_ball_integral( mean, sigma, amp,
                                           skew_parameters[0], skew_parameters[1],
                                           skew_parameters[2], skew_parameters[3],
                                           energies, channels, nchannel );
        break;
        
      case PeakDef::SkewType::GaussExp:
        gauss_exp_integral( mean, sigma, amp, skew_parameters[0], energies, channels, nchannel );
        break;
        
      case PeakDef::SkewType::ExpGaussExp:
        exp_gauss_exp_integral( mean, sigma, amp, skew_parameters[0], skew_parameters[1], energies, channels, nchannel );
        break;
    }//switch( skew_type )
  }//void photopeak_function_integral(...)
  
  /** Returns the PDF for a unit-area Bortel function.
   */
  double bortel_pdf( const double mean, const double sigma, const double skew_low, const double x )
  {
    // 32-bit floats have a normalized range of 1E-38 to 1E38; 64bit floats 1E-308 to 1E308
    // We could use the proper functions up to ~1E308, but to be conservative, but to be
    // a little conservative, we'll switch to using a gaussian when the exp() and erfc()
    // functions start returning values with limits near 1E-38 or 1E38.
    // Although difference between the methods will start out ar ~30% and increase to >100%,
    // the function values are so small, they dont really matter.
    // TODO: try expanding the function, around (or above) `mean` to see if there can be a better approximation
    
    const double exp_arg = ((x - mean)/skew_low) + (sigma*sigma/(2*skew_low*skew_low));
    const double erfc_arg = 0.7071067812*(((x - mean)/sigma) + (sigma/skew_low));
    
    if( (skew_low <= 0.0) || (exp_arg > 87.0) || (erfc_arg > 10.0) )
    {
      const double a = (x-mean)/sigma;
      return (1.0/(sigma*2.5066282746)) * std::exp( -0.5 * a*a );
    }
    
    return (0.5/skew_low)*std::exp( exp_arg ) * boost::math::erfc( erfc_arg );
  }//double bortel_pdf(...)


  /** Returns the indefinite integral (e.g., from negative infinity up to `x`) of a unit-area Bortel function
   */
  double bortel_indefinite_integral( const double x, const double mean,
                           const double sigma, const double skew )
  {
    const double sqrt2 = boost::math::constants::root_two<double>();
    const double oneOverSqrt2 = boost::math::constants::one_div_root_two<double>();
   
    const double x_0 = x - mean;
    const double erf_arg = x_0/(sigma*sqrt2);
    const double exp_arg = (2*skew*x_0 + sigma*sigma) / (2*skew*skew);
    const double erfc_arg = oneOverSqrt2*((x_0/sigma) + (sigma/skew));
    
    if( (skew <= 0.0) || (exp_arg > 87.0) || (erfc_arg > 10.0) )
      return 0.5 * boost_erf_imp(erf_arg);
    
    return 0.5*(boost_erf_imp(erf_arg) + (std::exp(exp_arg) * boost::math::erfc(erfc_arg)));
  }//double bortel_indefinite

  
  double bortel_integral( const double mean, const double sigma, const double skew,
                         const double x1, const double x2 )
  {
    return bortel_indefinite_integral(x2, mean, sigma, skew )
      - bortel_indefinite_integral(x1, mean, sigma, skew );
  }

  /** Returns an approximate area between `x1` and `x2` for a unit-area Bortel function.
   
   Just multiplies the x-range by the Bortel PDF value in the middle of the range.
   */
  double bortel_integral_fast( const double mean, const double sigma, const double skew,
                              const double x1, const double x2 )
  {
    const double half_way_x = 0.5*(x1 + x2);
    return (x2 - x1) * bortel_pdf( mean, sigma, skew, half_way_x );
  }
  
  
  double crystal_ball_norm( const double sigma,
                           const double alpha,
                           const double n )
  {
    const double oneOverSqrt2 = boost::math::constants::one_div_root_two<double>();
    const double sqrt_half_pi = boost::math::constants::root_half_pi<double>();
    
    const double C = (n / alpha) * (1.0/(n - 1.0)) * std::exp( -0.5*alpha*alpha );
    const double D = sqrt_half_pi * (1.0 + boost_erf_imp( oneOverSqrt2 * alpha ));
    const double N = 1.0 / (sigma * (C + D));
    
    return N;
  }
  
  double crystal_ball_pdf(const double mean,
                          const double sigma,
                          const double alpha,
                          const double n,
                          const double x )
  {
    // From https://en.wikipedia.org/wiki/Crystal_Ball_function
    assert( alpha > 0.0 );
    if( alpha <= 0.0 )
      throw runtime_error( "crystal_ball_pdf: alpha must be >0" );
    
    assert( n > 1.0 );
    if( n <= 1.0 )
      throw runtime_error( "crystal_ball_pdf: power-law must be >1" );
    
    const double N = crystal_ball_norm( sigma, alpha, n );
    const double t = (x - mean) / sigma;
    
    if( t <= -alpha )
    {
      const double A = std::pow( n/alpha, n) * std::exp( -0.5*alpha*alpha );
      const double B = (n / alpha) - alpha;
      return N*A*std::pow( B - t, -n );
    }
    
    return N * std::exp( -0.5*t*t );
  }//crystal_ball_pdf


  /** Returns indefinite integral (negative infinite to `x0` for the power-law component for the unit-area Crystal Ball function.
   */
  double crystal_ball_tail_indefinite_t( const double sigma,
                                          const double alpha,
                                          const double n,
                                          const double t )
  {
    // TODO: this is just a niave implementation - still needs to be optimized
    // The CERN ROOT implementation switches to a log-version of this integral when `n` is
    //  less than 1 + 1E-5 - which makes sense, but for the moment lets just avoid n approaching 1
    assert( t <= -alpha );
    assert( alpha > 0.0 );
    assert( n > 1.0 );
    
    const double oneOverSqrt2 = boost::math::constants::one_div_root_two<double>(); //0.7071....
    const double sqrt_half_pi = boost::math::constants::root_half_pi<double>();
    
    const double A = std::pow(n/alpha, n) * std::exp( -0.5*alpha*alpha );
    const double B = (n / alpha) - alpha;
    const double C = (n / alpha) * (1.0/(n - 1.0)) * std::exp( -0.5*alpha*alpha );
    const double D = sqrt_half_pi * (1.0 + boost_erf_imp( oneOverSqrt2 * alpha ));
    const double N = 1.0 / (sigma * (C + D));
    
    return N * A * sigma * std::pow( B - t, 1.0 - n ) / (n - 1.0);
  }//crystal_ball_tail_indefinite_t

  /*
  double DSCB_pdf_non_norm( const double mean, const double sigma,
                            const double alpha_low, const double n_low,
                            const double alpha_high, const double n_high,
                            const double x )
  {
    // From chapter 6 of https://arxiv.org/pdf/1606.03833.pdf
    double t = (x - mean) / sigma;
    
    if( (t >= -alpha_low) && (t <= alpha_high) ) //Return gaussian value
      return std::exp(-0.5*t*t);
    
    // Return tail value
    const double n = (t > 0.0) ? n_high : n_low;
    const double alpha = (t > 0.0) ? alpha_high : alpha_low;
    t = (t > 0.0) ? -t : t;
    
    //return std::exp(-0.5*alpha*alpha) * std::pow( (alpha/n)*((n/alpha) - alpha - t), -n );
    return std::exp(-0.5*alpha*alpha) * std::pow((1.0 - ((alpha + t) * (alpha / n))), -n); //slightly more stable version of above
  }
   */

  double DSCB_norm( const double alpha_low, const double n_low,
                    const double alpha_high, const double n_high )
  {
    assert( alpha_low > 0 );
    assert( alpha_high > 0 );
    assert( n_low > 1 );
    assert( n_high > 1 );
    
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
    const double root_pi = boost::math::constants::root_pi<double>();
    
    
    double a = alpha_low;
    double n = n_low;
    // -(e^(-a*a/2)*n*((a*(-t+n/a-a))/n)^(1-n))/(a*(1-n))
    // -(e^(-a^2/2)*n^n*(-t+n/a-a)^(1-n))/((1-n)*a^n)
    //const double ltail = -(std::exp(-a*a/2)*n*std::pow((a*(a +n/a -a))/n,1-n))/(a*(1-n)); //From Integrating with Maxima
    const double ltail = -std::exp(-0.5*a*a) * n / (a * (1.0 - n)); //Simplifying, and making more numerically stable, using https://herbie.uwplse.org/demo/
    
    // L = alpha_low
    // R = alpha_high
    // (sqrt(pi)*(erf(R/sqrt(2))-erf(L/sqrt(2))))/sqrt(2)
    const double mid = (root_pi*one_div_root_two*(boost_erf_imp(alpha_high*one_div_root_two)
                                                   - boost_erf_imp(-alpha_low*one_div_root_two)));
    
    a = alpha_high;
    n = n_high;
    // Integrate [e^(-a^2/2)* (((a/n)*((n/a)-a+t))^(-n)] dt, from a to inifit
    // (e^(-a^2/2)*n*((a*(t+n/a-a))/n)^(1-n))/(a*(1-n))
    // (e^(-a^2/2)*n^n*(x+n/a-a)^(1-n))/((1-n)*a^n)
    //const double rtail = -(std::exp(-a*a/2)*n*std::pow((a*(a + n/a -a))/n,1-n))/(a*(1-n)); //From Integrating with Maxima
    const double rtail = -std::exp(-0.5*a*a) * n / (a * (1.0 - n));  //Simplifying, and making more numerically stable, using https://herbie.uwplse.org/demo/
    
    return 1.0 / (ltail + mid + rtail);
  }//DSCB_norm( ... )
  
  
  double DSCB_left_tail_indefinite_non_norm_t( const double alpha_low,
                                                          const double n_low,
                                                          const double t)
  {
    // Takes `t = (x - mean) / sigma`, not x
    assert( t <= -alpha_low );
    
    const double &a = alpha_low;
    const double &n = n_low;
    //return -(std::exp(-a*a/2)*n*std::pow((a*(-t+n/a-a))/n, 1-n))/(a*(1-n));
    const double t_1 = 1.0 - (a / (n / (a + t)));
    return -std::exp(-0.5*a*a)*(t_1 / std::pow(t_1, n)) / ((a / n) - a); //slightly more stsable
  }//double DSCB_left_tail_indefinite_non_norm_t(t)
  
  
  double DSCB_right_tail_indefinite_non_norm_t( const double alpha_high,
                                                           const double n_high,
                                                           const double t)
  {
    // Takes `t = (x - mean) / sigma`, not x
    assert( (t + 1.0E-7) >= alpha_high );
    
    const double &a = alpha_high;
    const double &n = n_high;
    
    // (e^(a^2/2)*n*((a*(t+n/a-a))/n)^(1-n))/(a*(1-n))
    //return (std::exp(-a*a/2)*n*std::pow((a*(t + n/a - a))/n,1-n))/(a*(1-n));
    return std::exp(-a*a/2)*(1.0 / ((a / n) - a)) * std::pow((1.0 + ((a * (t - a)) / n)), (1.0 - n));
  }
  
  double DSCB_gauss_indefinite_non_norm_t( const double t )
  {
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
    
    return root_half_pi * boost_erf_imp( one_div_root_two * t );
  }//DSCB_gauss_indefinite_non_norm_t(...)

  
  /** Returns the normalization so the GaussExp distribution has unit area. */
  double gauss_exp_norm( const double sigma, const double skew )
  {
    static const double sqrt_pi = boost::math::constants::root_pi<double>(); //1.7724538509055160272981
    static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    
    return 1.0 / ((sigma/skew)*std::exp(-0.5*skew*skew)
           + (sqrt_pi*one_div_root_two*(boost_erf_imp(skew*one_div_root_two)+1)*sigma));
  }
  
  double gauss_exp_pdf(const double mean,
                       const double sigma,
                       const double skew,
                       const double x )
  {
    const double t = (x - mean) / sigma;
    const double norm = gauss_exp_norm( sigma, skew );
    if( t >= -skew )
      return norm * std::exp( -0.5*t*t );
    return norm * std::exp( 0.5*skew*skew + skew*t );
  }
  
  double gauss_exp_tail_indefinite(const double mean,
                                  const double sigma,
                                  const double skew,
                                  const double x )
  {
    const double t = (x - mean) / sigma;
    assert( t <= skew );
    
    return gauss_exp_norm(sigma,skew)*(sigma/skew)*std::exp((skew/sigma)*(0.5*skew*sigma - mean + x));
  }
  
  double gauss_exp_indefinite(const double mean,
                             const double sigma,
                             const double skew,
                             const double x )
  {
    const double t = (x - mean) / sigma;
    
    const double root_half_pi = boost::math::constants::root_half_pi<double>();
    static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    
    double answer = gauss_exp_tail_indefinite( mean, sigma, skew, std::min(x,-skew*sigma + mean) );
    if( t >= -skew )
      answer += gauss_exp_norm(sigma,skew)*sigma*root_half_pi
                 * (boost_erf_imp(t*one_div_root_two) - boost_erf_imp(-skew*one_div_root_two) );
    return answer;
  }
  
  
  double gauss_exp_integral( const double mean, const double sigma, const double skew, const double x1, const double x2 )
  {
    return gauss_exp_indefinite(mean, sigma, skew, x2) - gauss_exp_indefinite(mean, sigma, skew, x1);
  }
      
  
  double exp_gauss_exp_norm( const double sigma, const double skew_left, const double skew_right )
  {
    static const double sqrt_pi = boost::math::constants::root_pi<double>(); //1.7724538509055160272981
    static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    
    return 1.0 / ((sigma/skew_left)*std::exp(-0.5*skew_left*skew_left)
                  + (one_div_root_two*sqrt_pi*sigma*(boost_erf_imp(one_div_root_two*skew_right)+boost_erf_imp(one_div_root_two*skew_left)))
                  + (sigma/skew_right)*std::exp(-0.5*skew_right*skew_right) );
  }//exp_gauss_exp_norm(...)

  
  double exp_gauss_exp_pdf( const double mean,
                           const double sigma,
                           const double skew_left,
                           const double skew_right,
                           const double x )
  {
    const double t = (x - mean) / sigma;
    const double norm = exp_gauss_exp_norm( sigma, skew_left, skew_right );
    if( t > skew_right )
      return norm*std::exp( 0.5*skew_right*skew_right - skew_right*t );
    
    if( t > -skew_left )
      return norm*std::exp( -0.5*t*t );
      
    return norm*std::exp( 0.5*skew_left*skew_left + skew_left*t );
  }//double exp_gauss_exp_pdf(...)
  

  double exp_gauss_exp_left_tail_indefinite( const double mean,
                                          const double sigma,
                                          const double skew_left,
                                          const double skew_right,
                                          const double x )
  {
    //const double t = (x - mean) / sigma;
    const double norm = exp_gauss_exp_norm(sigma,skew_left,skew_right);
    return norm*(sigma/skew_left)*std::exp((skew_left/sigma)*(0.5*skew_left*sigma - mean + x));
  }

  double exp_gauss_exp_right_tail_indefinite( const double mean,
                                           const double sigma,
                                           const double skew_left,
                                           const double skew_right,
                                           const double x )
  {
    const double norm = exp_gauss_exp_norm( sigma, skew_left, skew_right );
    const double &k = skew_right;
    const double &s = sigma;
    const double &m = mean;
    return norm*((std::exp(-k*k/2)*s)/k-(s*std::exp((k*m)/s-(x*k)/s+k*k/2))/k);
  }

  double exp_gauss_exp_gauss_indefinite( const double mean,
                                      const double sigma,
                                      const double skew_left,
                                      const double skew_right,
                                      const double x )
  {
    static const double sqrt_pi = boost::math::constants::root_pi<double>(); //1.7724538509055160272981
    static const double sqrt_half_pi = boost::math::constants::root_half_pi<double>(); //1.2533141373155002512078826424
    static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
    
    const double t = (x - mean) / sigma;
    const double norm = exp_gauss_exp_norm( sigma, skew_left, skew_right);
    
    return norm * sigma * sqrt_half_pi * (boost_erf_imp( one_div_root_two*t )
                                          - boost_erf_imp( -one_div_root_two*skew_left ) );
  }//
  
  double exp_gauss_exp_indefinite( const double mean,
                                const double sigma,
                                const double skew_left,
                                const double skew_right,
                                const double x )
  {
    const double t = (x - mean) / sigma;
    double answer = exp_gauss_exp_left_tail_indefinite( mean, sigma, skew_left, skew_right, min(x,-skew_left*sigma + mean) );
    
    if( t > skew_right )
      answer += exp_gauss_exp_right_tail_indefinite( mean, sigma, skew_left, skew_right, x );
    
    if( t > -skew_left )
      answer += exp_gauss_exp_gauss_indefinite( mean, sigma, skew_left, skew_right, min(x,skew_right*sigma + mean) );
    
    return answer;
  }
  
  double exp_gauss_exp_integral(const double mean,
                           const double sigma,
                           const double skew_left,
                           const double skew_right,
                           const double x0,
                           const double x1 )
  {
    return exp_gauss_exp_indefinite(mean, sigma, skew_left, skew_right,x1)
        - exp_gauss_exp_indefinite(mean, sigma, skew_left, skew_right, x0);
  }
  
  
  double gaussian_integral( const double peak_mean, const double peak_sigma,
                            const double x0, const double x1 )
  {
    if( peak_sigma == 0.0 )
      return 0.0;

    const double sqrt2 = boost::math::constants::root_two<double>();  //M_SQRT2 (but need to use '#define _USE_MATH_DEFINES' before #include <cmath>)
    
    const double erflowarg = (x0 - peak_mean)/(sqrt2*peak_sigma);
    const double erfhigharg = (x1 - peak_mean)/(sqrt2*peak_sigma);
    
    return 0.5 * (boost_erf_imp(erfhigharg) - boost_erf_imp(erflowarg));
  }//double gaussian_integral(...)


  void gaussian_integral( const double peak_mean,
                              const double peak_sigma,
                              const double peak_amplitude,
                              const float * const energies,
                              double *channels,
                              const size_t nchannel )
  {
    if( peak_sigma==0.0 || peak_amplitude==0.0 )
      return;
    
    const double zero_amp_point_nsigma = 8.0;
    const float start_energy = static_cast<float>( peak_mean - zero_amp_point_nsigma*peak_sigma );
    const float stop_energy = static_cast<float>( peak_mean + zero_amp_point_nsigma*peak_sigma );
    
    size_t channel = 0;
    while( (channel < nchannel) && (energies[channel+1] < start_energy) )
    {
      channel += 1;
    }
    
    if( channel == nchannel )
      return;
    
    const double sqrt2 = boost::math::constants::root_two<double>();
    
    // We will keep track of the channels lower value of erf, so we dont have to re-compute
    //  it for each channel (this is the who advantage of )
    double erflow = boost_erf_imp( (energies[channel] - peak_mean)/(sqrt2*peak_sigma) );
    
    while( (channel < nchannel) && (energies[channel] < stop_energy) )
    {
      const double erfhigharg = (energies[channel+1] - peak_mean)/(sqrt2*peak_sigma);
      const double erfhigh = boost_erf_imp( erfhigharg );
      
      channels[channel] += 0.5 * peak_amplitude * (erfhigh - erflow);
      channel += 1;
      erflow = erfhigh;
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
  }//gaus_integral(...)

  
  
  
  void bortel_integral( const double mean, const double sigma, const double amp, const double skew,
                       const float * const energies, double *channels, const size_t nchannel )
  {
    assert( sigma > 0.0 );
    if( (sigma <= 0.0) || (amp <= 0.0) || !nchannel )
      return;
    
    const double zero_amp_point_nsigma_lower = 12.0; // TODO: Use the skew to determine lower energy
    const double zero_amp_point_nsigma_upper = 8.0;
    const float start_energy = static_cast<float>( mean - zero_amp_point_nsigma_lower*sigma );
    const float stop_energy = static_cast<float>( mean + zero_amp_point_nsigma_upper*sigma );
    
    size_t channel = 0;
    while( (channel < nchannel) && (energies[channel+1] < start_energy) )
    {
      channel += 1;
    }
    
    if( channel == nchannel )
      return;
    
    // We will keep track of the channels lower value indefinite integral, so we dont have to
    //  re-compute it for each channel
    double val_low = bortel_indefinite_integral(energies[channel], mean, sigma, skew );
    
    while( (channel < nchannel) && (energies[channel] < stop_energy) )
    {
      const double val_high = bortel_indefinite_integral(energies[channel+1], mean, sigma, skew );
      
      channels[channel] += amp*(val_high - val_low);
      val_low = val_high;
      channel += 1;
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
  }//bortel_integral( to array values)


  
  double crystal_ball_integral( const double mean,
                               const double sigma,
                               const double alpha,
                               const double n,
                               const double x0, const double x1 )
  {
    // TODO: this is just a niave implementation - still needs to be optimized
    
    // Also, the implementation in CERNs ROOT
    //  may better deal with numerical accuracies of tails by switching to integrating in log
    //   see https://root.cern.ch/doc/master/RooCrystalBall_8cxx_source.html
    const double oneOverSqrt2 = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
    const double sqrt_half_pi = boost::math::constants::root_half_pi<double>();
    
    const double a_0 = (x0 - mean) / sigma;
    const double a_1 = (x1 - mean) / sigma;
    
    if( (a_0 <= -alpha) && (a_1 <= -alpha) )
    {
      // Integrate just among the power law component
      return (crystal_ball_tail_indefinite_t(sigma,alpha,n,a_1)
                               - crystal_ball_tail_indefinite_t(sigma,alpha,n,a_0));
    }
    
    const double A = std::pow(n/alpha, n) * std::exp( -0.5*alpha*alpha );
    //const double B = (n / alpha) - alpha;
    const double C = (n / alpha) * (1.0/(n - 1.0)) * std::exp( -0.5*alpha*alpha );
    const double D = sqrt_half_pi * (1.0 + boost_erf_imp( oneOverSqrt2 * alpha ));
    //const double N = 1.0 / (sigma * (C + D));
    
    const double sqrt_2pi = boost::math::constants::root_two_pi<double>();
    
    const double gauss_amp = sqrt_2pi / (C + D);
    
    if( (a_0 >= -alpha) && (a_1 > -alpha) ) // just the gaussian
      return gauss_amp*gaussian_integral( mean, sigma, x0, x1 );
    
    // integrate power-law from a_0 to -alpha
    // integrate gaussian from -alpha to a_1
    return (crystal_ball_tail_indefinite_t(sigma,alpha,n,-alpha)
                             - crystal_ball_tail_indefinite_t(sigma,alpha,n,a_0))
    + gauss_amp*gaussian_integral( mean, sigma, mean-alpha*sigma, x1 );
  }//crystal_ball_integral(...)

  
  double double_sided_crystal_ball_integral( const double peak_mean,
                                            const double peak_sigma,
                                            const double alpha_low,
                                            const double n_low,
                                            const double alpha_high,
                                            const double n_high,
                                            const double x0, const double x1 )
  {
#ifdef _MSC_VER
#pragma message( "PeakDef::double_sided_crystal_ball_integral not tested/optimized - normalization for power law below 5 starts being off decently" )
#else
#warning "PeakDef::double_sided_crystal_ball_integral not tested/optimized - normalization for power law below 5 starts being off decently"
#endif
    
    const double t0 = (x0 - peak_mean) / peak_sigma;
    const double t1 = (x1 - peak_mean) / peak_sigma;
    
    double answer = 0.0;
    if( t0 < -alpha_low )
      answer += DSCB_left_tail_indefinite_non_norm_t( alpha_low, n_low, std::min(-alpha_low,t1) )
      - DSCB_left_tail_indefinite_non_norm_t( alpha_low, n_low, t0 );
    
    if( t1 > alpha_high )
      answer += DSCB_right_tail_indefinite_non_norm_t( alpha_high, n_high, t1 )
      - DSCB_right_tail_indefinite_non_norm_t( alpha_high, n_high, std::max(alpha_high,t0) );
    
    if( (t0 < alpha_high) && (t1 > -alpha_low) )
      answer += DSCB_gauss_indefinite_non_norm_t( min(alpha_high,t1) )
      - DSCB_gauss_indefinite_non_norm_t( max(-alpha_low,t0) );
    
    const double norm = DSCB_norm( alpha_low, n_low, alpha_high, n_high );
    return norm*answer;
  }//double_sided_crystal_ball_integral(...)

  
  
  
  void gauss_exp_integral( const double peak_mean,
                          const double peak_sigma,
                          const double peak_amplitude,
                          const double skew,
                          const float * const energies,
                          double *channels,
                          const size_t nchannel )
  {
#define USE_SIMPLE_GAUSS_EXP_IMP 0
    
#if( USE_SIMPLE_GAUSS_EXP_IMP )
    //compiled in debug mode, this implementation takes about 5 times as long as the more optimized version.
    
#ifdef _MSC_VER
#pragma message( "PeakDef::gauss_exp_integral is not properly coded" )
#else
#warning "PeakDef::gauss_exp_integral is not properly coded"
#endif
    
#if( PERFORM_DEVELOPER_CHECKS )
    double dist_sum = 0.0;
#endif
    
    for( size_t i = 0; i < nchannel; ++i )
    {
      const float x0 = energies[i];
      const float x1 = energies[i+1];
      const double val = peak_amplitude*PeakDists::gauss_exp_integral( peak_mean, peak_sigma, skew, x0, x1 );
      channels[i] += val;
      
#if( PERFORM_DEVELOPER_CHECKS )
      dist_sum += val;
      
      if( IsInf(channels[i]) || IsNan(channels[i]) )
      {
        cerr << "Found GausExp invalid counts, " << channels[i] << " from [" << x0 << ", " << x1 << "]:\n"
        << "\t" << setw(14) << "range:" << "[" << energies[0] << ", " << energies[nchannel] << "]\n"
        << "\t" << setw(14) << "min_energy =" << energies[0] << "\n"
        << "\t" << setw(14) << "max_energy =" << energies[nchannel] << "\n"
        << "\t" << setw(14) << "nchannel =" << nchannel << "\n"
        << "\t" << setw(14) << "mean =" << peak_mean << "\n"
        << "\t" << setw(14) << "sigma =" << peak_sigma << "\n"
        << "\t" << setw(14) << "amp =" << peak_amplitude << "\n"
        << "\t" << setw(14) << "skew =" << skew << "\n"
        << endl;
        cerr << endl;
      }//if( skew_type_t != PeakDef::NoSkew )
      
      //log_developer_error( __func__, "Invalid CSS color called back " );
#endif //PERFORM_DEVELOPER_CHECKS
    }
    
#if( PERFORM_DEVELOPER_CHECKS )
    //  cerr << "GaussExp sum over [" << energies[0] << "," << energies[nchannel] << "] is "
    //  << (dist_sum/peak_amplitude) << " (should be near 1)" << endl;
#endif
    
#else  //USE_SIMPLE_GAUSS_EXP_IMP
    
    if( (peak_sigma == 0.0) || (peak_amplitude == 0.0) )
      return;
    
    
     // TODO: estimate where we should actually start and stop computing values for
    //const double zero_amp_point_nsigma = 8.0;
    const float start_energy = energies[0]; //static_cast<float>( peak_mean - zero_amp_point_nsigma*peak_sigma );
    const float stop_energy = energies[nchannel]; //static_cast<float>( peak_mean + zero_amp_point_nsigma*peak_sigma );
    
    size_t channel = 0;
    while( (channel < nchannel) && (energies[channel+1] < start_energy) )
    {
      channel += 1;
    }
    
    if( channel == nchannel )
      return;
    
    
    const auto tail_indefinite_non_norm = [peak_mean,peak_sigma,skew]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      assert( (t - 1.0E-8) <= -skew );
      return (peak_sigma/skew)*std::exp((skew/peak_sigma)*(0.5*skew*peak_sigma - peak_mean + x));
    };
    
    const auto gaus_indefinite_non_norm = [peak_mean,peak_sigma,skew]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      assert( t >= -skew );
      
      const double root_half_pi = boost::math::constants::root_half_pi<double>();
      static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
      return peak_sigma*root_half_pi * boost_erf_imp(t*one_div_root_two);
    };
    
    const double norm = peak_amplitude * gauss_exp_norm( peak_sigma, skew );
    const double tail_end = peak_mean - peak_sigma*skew;
    
    
    if( energies[channel] < tail_end )
    {
      double indefinite_low = tail_indefinite_non_norm( energies[channel] );
      
      while( (channel < nchannel) && (energies[channel] < tail_end) )
      {
        const double upper_energy = energies[channel+1];
        
        double indefinite_high;
        if( upper_energy > tail_end )
        {
          indefinite_high = tail_indefinite_non_norm( tail_end );
          channels[channel] += norm * (indefinite_high - indefinite_low);
          break;
        }else
        {
          indefinite_high = tail_indefinite_non_norm( upper_energy );
          channels[channel] += norm * (indefinite_high - indefinite_low);
          indefinite_low = indefinite_high;
          channel += 1;
        }
      }//while( (channel < nchannel) && (energies[channel] < tail_end) )
    }//if( energies[channel] < tail_end )
    
    if( channel >= nchannel )
      return;
    
    assert( energies[channel+1] >= tail_end );
    double indefinite_low = gaus_indefinite_non_norm( std::max(1.0*energies[channel],tail_end) );
    
    while( (channel < nchannel) && (energies[channel] < stop_energy) )
    {
      const double upper_energy = energies[channel+1];
      const double indefinite_high = gaus_indefinite_non_norm( upper_energy );
      
      channels[channel] += norm * (indefinite_high - indefinite_low);
      indefinite_low = indefinite_high;
      channel += 1;
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
#endif  //USE_SIMPLE_GAUSS_EXP_IMP
  }//void PeakDef::gauss_exp_integral( ... array ... )
  
  
  void exp_gauss_exp_integral( const double peak_mean,
                              const double peak_sigma,
                              const double peak_amplitude,
                              const double skew_left,
                              const double skew_right,
                              const float * const energies,
                              double *channels,
                              const size_t nchannel )
  {
#define USE_SIMPLE_EGE_IMP 0
    
#if( USE_SIMPLE_EGE_IMP )
#ifdef _MSC_VER
#pragma message( "PeakDef::exp_gauss_exp_integral is not properly coded" )
#else
#warning "PeakDef::exp_gauss_exp_integral is not properly coded"
#endif
    
    for( size_t i = 0; i < nchannel; ++i )
    {
      const float x0 = energies[i];
      const float x1 = energies[i+1];
      
      channels[i] += peak_amplitude*PeakDists::exp_gauss_exp_integral( peak_mean, peak_sigma, skew_left, skew_right, x0, x1 );
      
#if( PERFORM_DEVELOPER_CHECKS )
      if( IsInf(channels[i]) || IsNan(channels[i]) )
      {
        cerr << "Found ExpGausExp invalid counts, " << channels[i] << " from [" << x0 << ", " << x1 << "]:\n"
        << "\t" << setw(14) << "range:" << "[" << energies[0] << ", " << energies[nchannel] << "]\n"
        << "\t" << setw(14) << "min_energy =" << energies[0] << "\n"
        << "\t" << setw(14) << "max_energy =" << energies[nchannel] << "\n"
        << "\t" << setw(14) << "nchannel =" << nchannel << "\n"
        << "\t" << setw(14) << "mean =" << peak_mean << "\n"
        << "\t" << setw(14) << "sigma =" << peak_sigma << "\n"
        << "\t" << setw(14) << "amp =" << peak_amplitude << "\n"
        << "\t" << setw(14) << "skew_left =" << skew_left << "\n"
        << "\t" << setw(14) << "skew_right =" << skew_right << "\n"
        << endl;
        cerr << endl;
      }//if( skew_type_t != PeakDef::NoSkew )
      
      //log_developer_error( __func__, "Invalid CSS color called back " );
#endif //PERFORM_DEVELOPER_CHECKS
    }//for( size_t i = 0; i < nchannel; ++i )
    
#else
    
    if( (peak_sigma == 0.0) || (peak_amplitude == 0.0) )
      return;
    
    
     // TODO: estimate where we should actually start and stop computing values for
    //const double zero_amp_point_nsigma = 8.0;
    const float start_energy = energies[0]; //static_cast<float>( peak_mean - zero_amp_point_nsigma*peak_sigma );
    const float stop_energy = energies[nchannel]; //static_cast<float>( peak_mean + zero_amp_point_nsigma*peak_sigma );
    
    size_t channel = 0;
    while( (channel < nchannel) && (energies[channel+1] < start_energy) )
    {
      channel += 1;
    }
    
    if( channel == nchannel )
      return;

    
    auto left_tail_indefinite_non_norm = [peak_mean,peak_sigma,skew_left]( const double x ) -> double {
      return (peak_sigma/skew_left)*std::exp((skew_left/peak_sigma)*(0.5*skew_left*peak_sigma - peak_mean + x));
    };
    
    const double r_const = (std::exp(-0.5*skew_right*skew_right/2)*peak_sigma)/skew_right;
    auto right_tail_indefinite_non_norm = [peak_mean,peak_sigma,skew_right,r_const]( const double x ) -> double {
      return (r_const-(peak_sigma*std::exp((skew_right*peak_mean)/peak_sigma-(x*skew_right)/peak_sigma+0.5*skew_right*skew_right))/skew_right);
    };
    
    auto gauss_indefinite_non_norm = [peak_mean,peak_sigma]( const double x ) -> double {
      static const double sqrt_half_pi = boost::math::constants::root_half_pi<double>(); //1.2533141373155002512078826424
      static const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.707106781186547524400
      
      const double t = (x - peak_mean) / peak_sigma;
      return peak_sigma * sqrt_half_pi * boost_erf_imp( one_div_root_two*t );
    };
    
    const double norm = peak_amplitude * exp_gauss_exp_norm( peak_sigma, skew_left, skew_right );
    
    const double left_tail_end = peak_mean - peak_sigma*skew_left;
    const double right_tail_start = peak_mean + peak_sigma*skew_right;
    
    
    if( energies[channel] < left_tail_end )
    {
      double indefinite_low = left_tail_indefinite_non_norm( energies[channel] );
      
      while( (channel < nchannel) && (energies[channel] < left_tail_end) )
      {
        const double upper_energy = energies[channel+1];
        
        if( upper_energy > left_tail_end )
        {
          const double indefinite_high = left_tail_indefinite_non_norm( left_tail_end );
          channels[channel] += norm * (indefinite_high - indefinite_low);
          break;
        }else
        {
          const double indefinite_high = left_tail_indefinite_non_norm( upper_energy );
          channels[channel] += norm * (indefinite_high - indefinite_low);
          indefinite_low = indefinite_high;
          channel += 1;
        }
      }//while( (channel < nchannel) && (energies[channel] < tail_end) )
    }//if( energies[channel] < tail_end )
    
    if( channel >= nchannel )
      return;
    
    assert( energies[channel+1] >= left_tail_end );
    double indefinite_low = gauss_indefinite_non_norm( std::max(1.0*energies[channel],left_tail_end) );
    
    while( (channel < nchannel) && (energies[channel] < right_tail_start) )
    {
      const double upper_energy = energies[channel+1];
      
      if( upper_energy > right_tail_start )
      {
        const double indefinite_high = gauss_indefinite_non_norm( right_tail_start );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        break;
      }else
      {
        const double indefinite_high = gauss_indefinite_non_norm( upper_energy );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        indefinite_low = indefinite_high;
        channel += 1;
      }
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
    
    
    if( channel >= nchannel )
      return;
    
    assert( energies[channel+1] >= right_tail_start );
    indefinite_low = right_tail_indefinite_non_norm( std::max(1.0*energies[channel],right_tail_start) );
    
    while( (channel < nchannel) && (energies[channel] < stop_energy) )
    {
      const double upper_energy = energies[channel+1];
      
      if( upper_energy > stop_energy )
      {
        const double indefinite_high = right_tail_indefinite_non_norm( right_tail_start );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        break;
      }else
      {
        const double indefinite_high = right_tail_indefinite_non_norm( upper_energy );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        indefinite_low = indefinite_high;
        channel += 1;
      }
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
#endif
  }

  
  void crystal_ball_integral( const double peak_mean,
                             const double peak_sigma,
                             const double peak_amplitude,
                             const double alpha,
                             const double power_law,
                             const float * const energies,
                             double *channels,
                             const size_t nchannel )
  {
#define USE_SIMPLE_CB_IMP 0
    
#if( PERFORM_DEVELOPER_CHECKS )
    double dist_sum = 0.0;
#endif

    
#if( USE_SIMPLE_CB_IMP )
    for( size_t i = 0; i < nchannel; ++i )
    {
      const float x0 = energies[i];
      const float x1 = energies[i+1];
      
      const double val = peak_amplitude*PeakDists::crystal_ball_integral( peak_mean, peak_sigma, alpha, power_law, x0, x1 );
      channels[i] += val;
      
#if( PERFORM_DEVELOPER_CHECKS )
      dist_sum += val;
#endif
      
#if( PERFORM_DEVELOPER_CHECKS )
      if( IsInf(channels[i]) || IsNan(channels[i]) )
      {
        cerr << "Found Crystal Ball invalid counts, " << channels[i] << " from [" << x0 << ", " << x1 << "]:\n"
        << "\t" << setw(14) << "range:" << "[" << energies[0] << ", " << energies[nchannel] << "]\n"
        << "\t" << setw(14) << "min_energy =" << energies[0] << "\n"
        << "\t" << setw(14) << "max_energy =" << energies[nchannel] << "\n"
        << "\t" << setw(14) << "nchannel =" << nchannel << "\n"
        << "\t" << setw(14) << "mean =" << peak_mean << "\n"
        << "\t" << setw(14) << "sigma =" << peak_sigma << "\n"
        << "\t" << setw(14) << "amp =" << peak_amplitude << "\n"
        << "\t" << setw(14) << "alpha =" << alpha << "\n"
        << "\t" << setw(14) << "n =" << power_law << "\n"
        << endl;
        cerr << endl;
      }//if( skew_type_t != PeakDef::NoSkew )
      
      //log_developer_error( __func__, "..." );
#endif //PERFORM_DEVELOPER_CHECKS
    }//for( size_t i = 0; i < nchannel; ++i )
    

#else //USE_SIMPLE_CB_IMP
    
    
    if( (peak_sigma == 0.0) || (peak_amplitude == 0.0) )
      return;
    
    
     // TODO: estimate where we should actually start and stop computing values for
    //const double zero_amp_point_nsigma = 8.0;
    const float start_energy = energies[0]; //static_cast<float>( peak_mean - zero_amp_point_nsigma*peak_sigma );
    const float stop_energy = energies[nchannel]; //static_cast<float>( peak_mean + zero_amp_point_nsigma*peak_sigma );
    
    size_t channel = 0;
    while( (channel < nchannel) && (energies[channel+1] < start_energy) )
    {
      channel += 1;
    }
    
    if( channel == nchannel )
      return;
    
    
    const double exp_aa = std::exp(-0.5*alpha*alpha);
    const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
    const double sqrt_half_pi = boost::math::constants::root_half_pi<double>();
    const double sqrt_2pi = boost::math::constants::root_two_pi<double>();
    
    const double A = std::pow(power_law/alpha, power_law) * exp_aa;
    const double B = (power_law / alpha) - alpha;
    const double C = (power_law / alpha) * (1.0/(power_law - 1.0)) * exp_aa;
    const double D = sqrt_half_pi * (1.0 + boost_erf_imp( one_div_root_two * alpha ));
    const double N = 1.0 / (peak_sigma * (C + D));
    const double tail_amp = peak_amplitude * N * A * peak_sigma;
    const double gauss_indef_amp = 0.5 * peak_amplitude * sqrt_2pi / (C + D);
    
    // Brief implementation of crystal_ball_tail_indefinite_t
    auto tail_indefinite = [peak_mean,peak_sigma,alpha,power_law,B,tail_amp]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      assert( (t <= -alpha) && (alpha > 0.0) && (power_law > 1.0) );
      return tail_amp * std::pow( B - t, 1.0 - power_law ) / (power_law - 1.0);
    };
    
    auto gauss_indefinite = [peak_mean,peak_sigma,gauss_indef_amp,one_div_root_two]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      return gauss_indef_amp * boost_erf_imp( one_div_root_two * t );
    };
    
    
    const double tail_end = peak_mean - peak_sigma*alpha;    
    
    if( energies[channel] < tail_end )
    {
      double indefinite_low = tail_indefinite( energies[channel] );
      
      while( (channel < nchannel) && (energies[channel] < tail_end) )
      {
        assert( energies[channel] < energies[channel+1] );
        
        const double upper_energy = energies[channel+1];
        
        if( upper_energy > tail_end )
        {
          const double indefinite_high = tail_indefinite( tail_end );
          const double val = (indefinite_high - indefinite_low);
          channels[channel] += val;
    #if( PERFORM_DEVELOPER_CHECKS )
          dist_sum += val;
    #endif
          break;
        }else
        {
          const double indefinite_high = tail_indefinite( upper_energy );
          const double val = (indefinite_high - indefinite_low);
          channels[channel] += val;
          indefinite_low = indefinite_high;
          channel += 1;
        }
      }//while( (channel < nchannel) && (energies[channel] < tail_end) )
    }//if( energies[channel] < tail_end )
    
    if( channel >= nchannel )
      return;
    
    assert( energies[channel+1] >= tail_end );
    double indefinite_low = gauss_indefinite( std::max(1.0*energies[channel],tail_end) );
    
    while( (channel < nchannel) && (energies[channel] < stop_energy) )
    {
      assert( energies[channel] < energies[channel+1] );
      const double upper_energy = energies[channel+1];
      
      const double indefinite_high = gauss_indefinite( upper_energy );
      const double val = (indefinite_high - indefinite_low);
      channels[channel] += val;
      indefinite_low = indefinite_high;
      channel += 1;
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
#endif //USE_SIMPLE_CB_IMP
    
    
#if( PERFORM_DEVELOPER_CHECKS )
    /*
     const double frac = dist_sum / peak_amplitude;
     cerr << "Crystal Ball sum over [" << energies[0] << "," << energies[nchannel] << "] is "
     << frac << " (should be near 1)" << endl;
     
     if( fabs(1 - frac) > 0.01 )
     {
     cerr << "alpha(x) -> " << (peak_mean - alpha*peak_sigma) << endl;
     for( size_t i = 0; i < nchannel; ++i )
     cout << setw(5) << i << setw(12) << std::fixed << setprecision(2) << energies[i]
     << setw(12) << std::scientific << (channels[i]/peak_amplitude) << endl;
     
     cerr << "Single step integral is "
     << PeakDef::crystal_ball_integral( peak_mean, peak_sigma, 1.0, alpha, power_law, energies[0], energies[nchannel] )
     << " and over all area: "
     << PeakDef::crystal_ball_integral( peak_mean, peak_sigma, 1.0, alpha, power_law, peak_mean - 50*peak_sigma, peak_mean + 20*peak_sigma )
     << endl;
     }//if( fabs(1 - frac) > 0.01 )
     */
#endif
    
  }//crystal_ball_integral(...)

  
  void double_sided_crystal_ball_integral( const double peak_mean,
                                          const double peak_sigma,
                                          const double peak_amplitude,
                                          const double lower_alpha,
                                          const double lower_power_law,
                                          const double upper_alpha,
                                          const double upper_power_law,
                                          const float * const energies,
                                          double *channels,
                                          const size_t nchannel )
  {
#define USE_SIMPLE_DSCB_IMP 0
    
#if( USE_SIMPLE_DSCB_IMP )
    //compiled in debug mode, this implementation takes about X times as long as the more optimized version.
    
#ifdef _MSC_VER
#pragma message( "PeakDef::double_sided_crystal_ball_integral is not properly coded" )
#else
#warning "PeakDef::double_sided_crystal_ball_integral is not properly coded"
#endif
    
#if( PERFORM_DEVELOPER_CHECKS )
    double dist_sum = 0.0;
#endif
    
    for( size_t i = 0; i < nchannel; ++i )
    {
      const float x0 = energies[i];
      const float x1 = energies[i+1];
      
      const double val = peak_amplitude*PeakDists::double_sided_crystal_ball_integral( peak_mean, peak_sigma,
                                                                       lower_alpha, lower_power_law,
                                                                       upper_alpha, upper_power_law, x0, x1 );
      channels[i] += val;
      
#if( PERFORM_DEVELOPER_CHECKS )
      dist_sum += val;
      
      if( IsInf(channels[i]) || IsNan(channels[i]) )
      {
        cerr << "Found Double Sided Crystal Ball invalid counts, " << channels[i] << " from [" << x0 << ", " << x1 << "]:\n"
        << "\t" << setw(14) << "range:" << "[" << energies[0] << ", " << energies[nchannel] << "]\n"
        << "\t" << setw(14) << "min_energy =" << energies[0] << "\n"
        << "\t" << setw(14) << "max_energy =" << energies[nchannel] << "\n"
        << "\t" << setw(14) << "nchannel =" << nchannel << "\n"
        << "\t" << setw(14) << "mean =" << peak_mean << "\n"
        << "\t" << setw(14) << "sigma =" << peak_sigma << "\n"
        << "\t" << setw(14) << "amp =" << peak_amplitude << "\n"
        << "\t" << setw(14) << "lower_alpha =" << lower_alpha << "\n"
        << "\t" << setw(14) << "lower_power_law =" << lower_power_law << "\n"
        << "\t" << setw(14) << "upper_alpha =" << upper_alpha << "\n"
        << "\t" << setw(14) << "upper_power_law =" << upper_power_law << "\n"
        << endl;
        cerr << endl;
      }//if( skew_type_t != PeakDef::NoSkew )
      
      //log_developer_error( __func__, "..." );
#endif //PERFORM_DEVELOPER_CHECKS
    }
    
#if( PERFORM_DEVELOPER_CHECKS )
    const double frac = dist_sum / peak_amplitude;
    //cerr << "Double Sided Crystal Ball sum over [" << energies[0] << "," << energies[nchannel] << "] is "
    //<< frac << " (should be near 1)" << endl;
    
    if( fabs(1 - frac) > 0.01 )
    {
      cerr << "alpha_low(x) -> " << (peak_mean - lower_alpha*peak_sigma) << endl;
      cerr << "upper_alpha(x) -> " << (peak_mean - upper_alpha*peak_sigma) << endl;
      //for( size_t i = 0; i < nchannel; ++i )
      //  cout << setw(5) << i << setw(12) << std::fixed << setprecision(2) << energies[i]
      //  << setw(12) << std::scientific << (channels[i]/peak_amplitude) << endl;
      
      cerr << "Single step integral is "
      << PeakDists::double_sided_crystal_ball_integral(peak_mean, peak_sigma,
                                                       lower_alpha, lower_power_law,
                                                       upper_alpha, upper_power_law,
                                                       energies[0], energies[nchannel] )
      << " and over all area: "
      << PeakDists::double_sided_crystal_ball_integral(peak_mean, peak_sigma,
                                                       lower_alpha, lower_power_law,
                                                       upper_alpha, upper_power_law,
                                                       peak_mean - 50*peak_sigma, peak_mean + 30*peak_sigma )
      << endl;
    }//if( fabs(1 - frac) > 0.01 )
#endif
    
#else //USE_SIMPLE_DSCB_IMP
    
    
    if( (peak_sigma == 0.0) || (peak_amplitude == 0.0) )
      return;
    
    
     // TODO: estimate where we should actually start and stop computing values for
    //const double zero_amp_point_nsigma = 8.0;
    const float start_energy = energies[0]; //static_cast<float>( peak_mean - zero_amp_point_nsigma*peak_sigma );
    const float stop_energy = energies[nchannel]; //static_cast<float>( peak_mean + zero_amp_point_nsigma*peak_sigma );
    
    size_t channel = 0;
    while( (channel < nchannel) && (energies[channel+1] < start_energy) )
    {
      channel += 1;
    }
    
    if( channel == nchannel )
      return;
    
    const double exp_lower_aa = std::exp(-0.5*lower_alpha*lower_alpha);
    const double exp_upper_aa = std::exp(-0.5*upper_alpha*upper_alpha);
    
    auto left_tail_indefinite_non_norm = [peak_mean,peak_sigma,lower_alpha,lower_power_law, exp_lower_aa]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      assert( t <= -lower_alpha );
      
      const double &a = lower_alpha;
      const double &n = lower_power_law;
      const double t_1 = 1.0 - (a / (n / (a + t)));
      return -exp_lower_aa*(t_1 / std::pow(t_1, n)) / ((a / n) - a); //slightly more stable
    };
    
    auto right_tail_indefinite_non_norm = [peak_mean,peak_sigma,upper_alpha,upper_power_law,exp_upper_aa]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      assert( (t + 1.0E-7) >= upper_alpha );
      
      const double &a = upper_alpha;
      const double &n = upper_power_law;

      return exp_upper_aa*(1.0 / ((a / n) - a)) * std::pow((1.0 + ((a * (t - a)) / n)), (1.0 - n));
    };
    
    
    auto gauss_indefinite_non_norm = [peak_mean,peak_sigma]( const double x ) -> double {
      const double t = (x - peak_mean) / peak_sigma;
      const double root_half_pi = boost::math::constants::root_half_pi<double>();
      const double one_div_root_two = boost::math::constants::one_div_root_two<double>(); //0.70710678118654752440
      
      return root_half_pi * boost_erf_imp( one_div_root_two * t );
    };
    
    
    
    const double norm = peak_amplitude * DSCB_norm( lower_alpha, lower_power_law, upper_alpha, upper_power_law);
    
    const double left_tail_end = peak_mean - peak_sigma*lower_alpha;
    const double right_tail_start = peak_mean + peak_sigma*upper_alpha;
    
    
    if( energies[channel] < left_tail_end )
    {
      double indefinite_low = left_tail_indefinite_non_norm( energies[channel] );
      
      while( (channel < nchannel) && (energies[channel] < left_tail_end) )
      {
        const double upper_energy = energies[channel+1];
        
        if( upper_energy > left_tail_end )
        {
          const double indefinite_high = left_tail_indefinite_non_norm( left_tail_end );
          channels[channel] += norm * (indefinite_high - indefinite_low);
          break;
        }else
        {
          const double indefinite_high = left_tail_indefinite_non_norm( upper_energy );
          channels[channel] += norm * (indefinite_high - indefinite_low);
          indefinite_low = indefinite_high;
          channel += 1;
        }
      }//while( (channel < nchannel) && (energies[channel] < tail_end) )
    }//if( energies[channel] < tail_end )
    
    if( channel >= nchannel )
      return;
    
    assert( energies[channel+1] >= left_tail_end );
    double indefinite_low = gauss_indefinite_non_norm( std::max(1.0*energies[channel],left_tail_end) );
    
    while( (channel < nchannel) && (energies[channel] < right_tail_start) )
    {
      const double upper_energy = energies[channel+1];
      
      if( upper_energy > right_tail_start )
      {
        const double indefinite_high = gauss_indefinite_non_norm( right_tail_start );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        break;
      }else
      {
        const double indefinite_high = gauss_indefinite_non_norm( upper_energy );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        indefinite_low = indefinite_high;
        channel += 1;
      }
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
    
    
    if( channel >= nchannel )
      return;
    
    assert( energies[channel+1] >= right_tail_start );
    indefinite_low = right_tail_indefinite_non_norm( std::max(1.0*energies[channel],right_tail_start) );
    
    while( (channel < nchannel) && (energies[channel] < stop_energy) )
    {
      const double upper_energy = energies[channel+1];
      
      if( upper_energy > stop_energy )
      {
        const double indefinite_high = right_tail_indefinite_non_norm( right_tail_start );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        break;
      }else
      {
        const double indefinite_high = right_tail_indefinite_non_norm( upper_energy );
        channels[channel] += norm * (indefinite_high - indefinite_low);
        indefinite_low = indefinite_high;
        channel += 1;
      }
    }//while( (channel < nchannel) && (energies[channel] < stop_energy) )
#endif //USE_SIMPLE_DSCB_IMP
  }//double_sided_crystal_ball_integral(...)

}//namespace PeakDists
